#!/usr/bin/python3

import logging
import os
import re
import sys
from typing import List, NamedTuple, Optional

def main() -> int:
    logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.WARNING)
    log = logging.getLogger(__name__)

    print('''<!--

This file is auto-generated. Direct changes to it maybe lost.

Use update-index to regenerate it:

    ./update-index > INDEX.md

-->''')
    print()

    print('# Meta')
    print()
    designs = []
    for dirname, subdirs, files in os.walk('meta'):
        for f in files:
            path = os.path.join(dirname, f)
            if path.endswith('.md'):
                design = parse_design(path, True, log)
                if design:
                    designs.append(design)

    designs = sorted(designs, key=lambda d: d.title)
    print('| Design Name |')
    print('| ----------- |')
    for design in designs:
        print('| [%s](%s) |' % (design.title, design.path))
    print()

    print('# Accepted')
    print()
    designs = []
    for dirname, subdirs, files in os.walk('accepted'):
        for f in files:
            path = os.path.join(dirname, f)
            if path.endswith('.md'):
                design = parse_design(path, False, log)
                if design:
                    designs.append(design)

    designs = sorted(designs, key=lambda d: d.title)
    designs = sorted(designs, key=lambda d: d.year)
    print('| Year | Design Name | Owners |')
    print('| ---- | ----------- | ------ |')
    for design in designs:
        print('| %s | [%s](%s) | %s |' % (design.year,
                                          design.title,
                                          design.path,
                                          ', '.join(design.owners)))
    print()

    print('# Proposed')
    print()
    designs = []
    for dirname, subdirs, files in os.walk('proposed'):
        for f in files:
            path = os.path.join(dirname, f)
            if path.endswith('.md'):
                design = parse_design(path, True, log)
                if design:
                    designs.append(design)

    designs = sorted(designs, key=lambda d: d.title)
    print('| Design Name | Owners |')
    print('| ----------- | ------ |')
    for design in designs:
        print('| [%s](%s) | %s |' % (design.title, design.path, ', '.join(design.owners)))
    print()

    return 0

class Design(NamedTuple):
    path: str
    title: str
    year: Optional[int]
    owners: List[str]

def parse_design(f, everything_is_a_design: bool, log) -> Optional[Design]:
    OWNER_REGEX = r'^\*\*(?:Libraries)? *Owner ?\*\*(.+)$'

    title = ''
    year = None
    try:
        year = int(f.split('/')[1])
    except ValueError:
        pass

    owners: List[str] = []

    log.info(f'parsing {f}')

    with open(f) as proposal:
        for line in proposal.readlines()[:10]:
            line = line.strip()
            if not title and line.startswith('#') and not line.startswith('##'):
                title = line[1:]
                if title.endswith(' #'):
                    title = title[:-2]
                title = title.strip()
            owner_match = re.search(OWNER_REGEX, line)
            if owner_match:
                name = owner_match.group(1)
                # pipe char breaks how we use the name, plus it's not actually part of the name
                name = name.replace('|', '')
                an_owner = name.strip()
                owners.append(an_owner)

    # Some designs have sub-designs, so use a heuristic relying on
    # the Owner field to find the 'main' designs
    if not everything_is_a_design and not owners:
        log.debug(f'{f} is NOT a design')
        return None

    if not title:
        log.warning(f'Unable to parse a title from design {f}')

    if not owners:
        log.warning(f'No Owner for {f}')

    return Design(f, title, year, owners)

if __name__ == '__main__':
    sys.exit(main())

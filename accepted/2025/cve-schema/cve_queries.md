# CVE Query Catalog

This document provides a comprehensive catalog of jq queries for the CVE schema, organized by use case and complexity. All examples assume the JSON data is saved as `cve.json`.

All queries that produce multiple rows of multi-fact information are presented as tables. Tables are a structured information store on the same level as CSV, as compared to constructed strings with arbitrary separator symbols.

The following scripts run the queries:

- [jq_queries.sh](./jq_queries.sh) -- Runs the queries using only information found in [cve.json](./cve.json).
- [jq_queries_with_taxonomy.sh](./jq_queries_with_taxonomy.sh) -- Runs a subset of the queries with enhanced display names acquired by slurping the additional JSON files provided.

## Basic Lookups

### Get all CVE IDs
```bash
jq -r '.cves[].id' cve.json
```
[ğŸ“ get_all_cve_ids.jq](jq_queries/get_all_cve_ids.jq)

### Get CVEs by severity
```bash
jq -r '.cves[] | select(.severity == "critical") | .id' cve.json
```
[ğŸ“ get_cves_by_severity.jq](jq_queries/get_cves_by_severity.jq)

### Get CVE details
```bash
jq -r '.cves[] | "\(.id): \(.problem)"' cve.json
```
[ğŸ“ get_cve_details.jq](jq_queries/get_cve_details.jq)

## Index-Based Queries

### CVEs affecting a specific release
```bash
jq -r '.release_cves["8.0"][]' cve.json
```
[ğŸ“ cves_by_release.jq](jq_queries/cves_by_release.jq)

### Releases affected by a CVE
```bash
jq -r '.cve_releases["CVE-2024-38095"][]' cve.json
```
[ğŸ“ releases_by_cve.jq](jq_queries/releases_by_cve.jq)

### CVEs affecting a product
```bash
jq -r '.product_cves["dotnet-runtime-aspnetcore"][]' cve.json
```
[ğŸ“ cves_by_product.jq](jq_queries/cves_by_product.jq)

## Component Analysis

### Get all affected products
```bash
jq -r '(["| Product | Release |",
        "| ------- | ------- |"] +
       [.products[] | "| \(.name) | \(.release) |"] |
       unique) |
       .[]' cve.json
```
[ğŸ“ get_all_affected_products.jq](jq_queries/get_all_affected_products.jq)

### Get fixed versions for products
```bash
jq -r '(["| CVE ID | Product | Fixed |",
        "| ------ | ------- | ----- |"] +
       [.products[] | "| \(.cve_id) | \(.name) | \(.fixed) |"]) |
       .[]' cve.json
```
[ğŸ“ get_fixed_versions_products.jq](jq_queries/get_fixed_versions_products.jq)

### Get fixed versions for extensions
```bash
jq -r '(["| CVE ID | Extension | Fixed |",
        "| ------ | --------- | ----- |"] +
       [.extensions[] | "| \(.cve_id) | \(.name) | \(.fixed) |"]) |
       .[]' cve.json
```
[ğŸ“ get_fixed_versions_extensions.jq](jq_queries/get_fixed_versions_extensions.jq)

## Commit Analysis

### Get commits for a CVE
```bash
jq -r '. as $root | .cve_commits["CVE-2024-38095"][] | $root.commits[.].url' cve.json
```
[ğŸ“ get_commits_for_cve.jq](jq_queries/get_commits_for_cve.jq)

### Get all commits for a release
```bash
jq -r '. as $root | .release_cves["8.0"][] as $cve | $root.cve_commits[$cve][] | $root.commits[.].url' cve.json
```
[ğŸ“ get_commits_for_release.jq](jq_queries/get_commits_for_release.jq)

### Repository commit summary
```bash
jq -r '. as $root | 
  .commits | 
  to_entries | 
  group_by(.value.repo) | 
  map({
    repo: .[0].value.repo, 
    commits: [.[] | .key] | length, 
    cves: ([.[] | .key as $hash | $root.cve_commits | to_entries[] | select(.value[] == $hash) | .key] | unique | length)
  }) | 
  (["| Repository | Commits | CVEs |",
    "| ---------- | ------- | ---- |"] +
   [.[] | "| \(.repo)  | \(.commits)       | \(.cves)    |"]) | 
  .[]' cve.json
```
[ğŸ“ repository_commit_summary.jq](jq_queries/repository_commit_summary.jq)

## Risk Assessment

### CVEs with release impact
```bash
jq -r '. as $root | 
  (["| CVE ID        | Severity | Releases | Problem |",
    "| ------------- | -------- | -------- | ------- |"] +
   [$root.cves[] | 
    .id as $cve | 
    "| \($cve)  | \(.severity) | \(($root.cve_releases[$cve] // []) | join(", "))     | \(.problem) |"]) | 
  .[]' cve.json
```
[ğŸ“ cves_with_release_impact.jq](jq_queries/cves_with_release_impact.jq)

### Components with multiple vulnerabilities
```bash
jq -r '[.products[], .extensions[]] | 
  group_by(.name) | 
  map({name: .[0].name, cves: [.[] | .cve_id] | unique}) | 
  map(select(.cves | length > 1)) |
  (["| Component | CVEs |",
    "| --------- | ---- |"] +
   [.[] | "| \(.name) | \(.cves | join(", ")) |"]) | 
  .[]' cve.json
```
[ğŸ“ components_with_multiple_vulnerabilities.jq](jq_queries/components_with_multiple_vulnerabilities.jq)

### Cross-component impact analysis
```bash
jq -r '. as $root | 
  [.products[], .extensions[]] | 
  group_by(.cve_id) | 
  (["| CVE ID        | Count | Components |",
    "| ------------- | ----- | ---------- |"] +
   [.[] | 
    "| \(.[0].cve_id)  | \([.[] | .name] | unique | length)     | \([.[] | .name] | unique | join(", ")) |"]) | 
  .[]' cve.json
```
[ğŸ“ cross_component_impact_analysis.jq](jq_queries/cross_component_impact_analysis.jq)

## Temporal Analysis

### Age of vulnerabilities (for compliance tracking)
```bash
jq -r --arg today "2025-09-01" '
  .cves[] | 
  "\(.id): \(((\"2025-09-01\" | strptime(\"%Y-%m-%d\") | mktime) - (.disclosed | strptime(\"%Y-%m-%d\") | mktime)) / 86400 | floor) days since disclosure"' cve.json
```
[ğŸ“ age_of_vulnerabilities.jq](jq_queries/age_of_vulnerabilities.jq)

## Version Vulnerability Assessment

### Check if specific version is vulnerable
```bash
jq -r --arg release "8.0" --arg version "8.0.5" '
  [.products[], .extensions[]] | 
  map(select(.release == $release)) |
  map(select(.min_vulnerable <= $version and .max_vulnerable >= $version)) |
  (["| CVE ID        | Component |",
    "| ------------- | --------- |"] +
   [.[] | "| \(.cve_id)  | \(.name) |"]) | 
  .[]' cve.json
```
[ğŸ“ check_version_vulnerable.jq](jq_queries/check_version_vulnerable.jq)

## Platform-Specific Analysis

### CVEs by platform
```bash
jq -r '(["| CVE ID        | Platforms |",
        "| ------------- | --------- |"] +
       [.cves[] | 
        "| \(.id)  | \(.platforms | join(", ")) |"]) | 
      .[]' cve.json
```
[ğŸ“ cves_by_platform.jq](jq_queries/cves_by_platform.jq)

## Advanced Queries

### Extensions requiring immediate attention
```bash
jq -r '. as $root | 
  [$root.cves[] | select(.severity == "critical") | .id] as $critical_cves |
  (["| CVE ID        | Extension |",
    "| ------------- | --------- |"] +
   [$root.extensions[] | 
    select(.cve_id as $cve | $critical_cves | contains([$cve])) | 
    "| \(.cve_id)  | \(.name) |"]) | 
  .[]' cve.json
```
[ğŸ“ extensions_requiring_immediate_attention.jq](jq_queries/extensions_requiring_immediate_attention.jq)

### Patch deployment summary for release
```bash
jq -r '. as $root |
  [.products[], .extensions[]] | 
  map(select(.release == "8.0")) | 
  group_by(.name) | 
  map({
    id: .[0].name,
    name: ($root.product_name[.[0].name] // .[0].name),
    versions: [.[] | .fixed] | unique | sort
  }) | 
  (["| Version | Component |", "| ------- | --------- |"] + 
  map("| \(.versions | last)   | \(.name) |")) | 
  .[]' cve.json
```
[ğŸ“ patch_deployment_summary.jq](jq_queries/patch_deployment_summary.jq)

### Release-independent extensions
```bash
jq -r '.extensions[] | 
  select(.release == "") |
  [{cve: .cve_id, version: .fixed, name: .name}] |
  (["| CVE ID        | Version | Extension |",
    "| ------------- | ------- | --------- |"] +
   [.[] | "| \(.cve)  | \(.version)    | \(.name) |"]) | 
  .[]' cve.json
```
[ğŸ“ release_independent_extensions.jq](jq_queries/release_independent_extensions.jq)

## Error Handling Patterns

### Defensive CVE lookup
```bash
jq -r --arg cve "CVE-2024-99999" '
  (.cve_releases[$cve] // ["Not found"]) | 
  if . == ["Not found"] then "CVE \($cve) not in database" 
  else "CVE \($cve) affects releases: \(join(", "))" end' cve.json
```
[ğŸ“ defensive_cve_lookup.jq](jq_queries/defensive_cve_lookup.jq)

### Safe version queries
```bash
jq -r '(.release_cves["9.0"] // []) | length' cve.json
```
[ğŸ“ safe_version_queries.jq](jq_queries/safe_version_queries.jq)

## Emergency Response Queries

### Immediate risk assessment
```bash
jq -r '.cves[] | 
  select(.severity == "critical") |
  [.] + [((.id as $id | [(.products // []), (.extensions // [])][] | select(.cve_id == $id)))] |
  "ğŸš¨ CRITICAL: \(.[0].id) affects \(length-1) components - \(.[0].problem)"' cve.json
```
[ğŸ“ immediate_risk_assessment.jq](jq_queries/immediate_risk_assessment.jq)

### Most vulnerable component
```bash
jq -r '[.products[], .extensions[]] | 
  group_by(.name) |
  map({name: .[0].name, count: length, cves: map(.cve_id)}) |
  sort_by(.count) | reverse |
  .[0] | "âš ï¸  Most vulnerable: \(.name) (\(.count) CVEs: \(.cves | join(", ")))"' cve.json
```
[ğŸ“ most_vulnerable_component.jq](jq_queries/most_vulnerable_component.jq)

## Taxonomy Integration Queries

The following queries demonstrate how to combine CVE data with the taxonomy JSON files to create human-readable reports with proper display names.

### CVE report with display names

Combine CVE data with severity and platform taxonomies:

```bash
jq -r --slurpfile severity severity.json --slurpfile platforms platforms.json '
  . as $cve_data |
  ($severity[0].items | map({(.string): .display_name}) | add) as $severity_names |
  ($platforms[0].items | map({(.string): .display_name}) | add) as $platform_names |
  
  (["| CVE ID | Severity | Platforms | Problem |",
    "| ------ | -------- | --------- | ------- |"] +
   [$cve_data.cves[] | 
    "| \(.id) | \($severity_names[.severity]) | \((.platforms | map($platform_names[.]) | join(", "))) | \(.problem) |"]) |
  .[]' cve.json
```
[ğŸ“ cve_report_with_display_names.jq](jq_queries/cve_report_with_display_names.jq)

### Product report with proper names

Show products with their official display names:

```bash
jq -r --slurpfile products products.json '
  . as $cve_data |
  ($products[0].items | map({(.string): .display_name}) | add) as $product_names |
  
  (["| Product | Display Name | CVEs |",
    "| ------- | ------------ | ---- |"] +
   [$cve_data.product_cves | to_entries[] |
    "| \(.key) | \($product_names[.key]) | \(.value | length) |"]) |
  .[]' cve.json
```
[ğŸ“ product_report_with_names.jq](jq_queries/product_report_with_names.jq)

### Security advisory with full taxonomy

Complete security report using all taxonomy files:

```bash
jq -r --slurpfile products products.json --slurpfile severity severity.json --slurpfile platforms platforms.json '
  . as $cve_data |
  ($severity[0].items | map({(.string): .display_name}) | add) as $severity_names |
  ($platforms[0].items | map({(.string): .display_name}) | add) as $platform_names |
  ($products[0].items | map({(.string): .display_name}) | add) as $product_names |
  
  "# Security Advisory Summary\n",
  "**Total CVEs:** \($cve_data.cves | length)\n",
  "**Critical CVEs:** \($cve_data.cves | map(select(.severity == \"critical\")) | length)\n",
  "\n## Affected Products\n",
  ([$cve_data.product_cves | to_entries[] |
    "- **\($product_names[.key])**: \(.value | length) CVE(s)"] | join("\n")),
  "\n\n## CVE Details\n",
  ([$cve_data.cves[] |
    "### \(.id) (\($severity_names[.severity]))",
    "- **Problem**: \(.problem)",  
    "- **Platforms**: \((.platforms | map($platform_names[.]) | join(", ")))",
    "- **Disclosed**: \(.disclosed)",
    ""
  ] | join("\n"))
' cve.json
```
[ğŸ“ security_advisory_full_taxonomy.jq](jq_queries/security_advisory_full_taxonomy.jq)

### Taxonomy validation

Verify that all values in CVE data have corresponding taxonomy entries:

```bash
# Check for missing severity mappings
jq -r --slurpfile severity severity.json '
  . as $cve_data |
  ($severity[0].items | map(.string)) as $valid_severities |
  [$cve_data.cves[].severity] | unique |
  map(select(. as $s | $valid_severities | contains([$s]) | not)) |
  if length > 0 then "âŒ Missing severity mappings: \(join(", "))" 
  else "âœ… All severities have taxonomy entries" end
' cve.json
```
[ğŸ“ validate_severity_mappings.jq](jq_queries/validate_severity_mappings.jq)

```bash
# Check for missing platform mappings  
jq -r --slurpfile platforms platforms.json '
  . as $cve_data |
  ($platforms[0].items | map(.string)) as $valid_platforms |
  [$cve_data.cves[].platforms[] // empty] | unique |
  map(select(. as $p | $valid_platforms | contains([$p]) | not)) |
  if length > 0 then "âŒ Missing platform mappings: \(join(", "))"
  else "âœ… All platforms have taxonomy entries" end  
' cve.json
```
[ğŸ“ validate_platform_mappings.jq](jq_queries/validate_platform_mappings.jq)

```bash
# Check for missing product mappings
jq -r --slurpfile products products.json '
  . as $cve_data |
  ($products[0].items | map(.string)) as $valid_products |
  [$cve_data.products[].name] | unique |
  map(select(. as $p | $valid_products | contains([$p]) | not)) |
  if length > 0 then "âŒ Missing product mappings: \(join(", "))"
  else "âœ… All products have taxonomy entries" end
' cve.json
```
[ğŸ“ validate_product_mappings.jq](jq_queries/validate_product_mappings.jq)

### Simplified taxonomy lookup helpers

Create reusable lookup functions for common display name needs:

```bash
# Simple severity display name lookup
jq -r --slurpfile severity severity.json --arg sev "critical" '
  ($severity[0].items | map({(.string): .display_name}) | add) as $names |
  $names[$sev]
' cve.json
```
[ğŸ“ severity_display_name_lookup.jq](jq_queries/severity_display_name_lookup.jq)

```bash
# Simple platform display names
jq -r --slurpfile platforms platforms.json '
  ($platforms[0].items | map({(.string): .display_name}) | add) as $names |
  ["all", "windows"] | map($names[.]) | join(", ")
' cve.json
```
[ğŸ“ platform_display_names.jq](jq_queries/platform_display_names.jq)

```bash
# Product descriptions for help text
jq -r --slurpfile products products.json --arg product "dotnet-runtime-libraries" '
  ($products[0].items | map({(.string): .description}) | add) as $descriptions |
  $descriptions[$product]
' cve.json
```
[ğŸ“ product_descriptions.jq](jq_queries/product_descriptions.jq)

---

*For schema documentation and design rationale, see [cve_schema.md](./cve_schema.md).*
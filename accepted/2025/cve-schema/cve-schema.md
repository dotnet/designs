# Publishing CVE information as structured data

We publish vulnerability fixes and matching CVE documentation nearly every month. These are [documented on GitHub in HTML](https://github.com/dotnet/announcements/issues?q=is%3Aissue%20state%3Aopen%20label%3ASecurity) for people to read. It is well understood that HTML is a presentation format and not appropriate for structured processing. We intend to offer CVE information in structured JSON format (and likely markdown, too).

This schema has been designed around a "product + extensions" model that reflects how many modern software platforms are structured - with product components and an ecosystem of extensions. This pattern is prevalent across the industry (editors with extensions, runtimes with packages, apps with plugins), making this schema broadly applicable beyond its initial .NET use case.

[.NET CVE Schema Implementation Guidance](./dotnet-guidance.md) provides insight and guidance on how this schema will be used by the .NET Team at Microsoft.

## Design philosophy

We've taken a significant departure with this schema design, battle-testing it with `jq` and some other tools as part of the development process. This approach has resulted in significant schema evolution relative to the intuitive (fully normalized) first draft. The new intuition: if the `jq` queries look bad, the schema is bad. We've also noticed in this new age that `jq` query ease is a proxy for LLM consumption ease. Great `jq` use will likely lead to good or better LLM consumption while bad `jq` queryability will likely lead to bad or worse LLM consumption. We intend to design all schema this way going forward.

The resulting tactical denormalization strategy successfully balances:

- Human readability with machine parseability
- Theoretical correctness with practical usability
- Specific .NET needs with general applicability
- Current requirements with future extensibility

This new CVE format will be part of a larger queryable information graph that we'll document soon. For now, we'll focus on the CVE format.

## Quick pitch

Common queries answered by this schema:

- "Which CVEs were reported this month?" → `.cves[].id`
- "Which CVEs affect .NET 8.0?" → `release-cves["8.0"]`
- "Which commits fix CVE-2024-38095?" → `cve-commits["CVE-2024-38095"]`
- "Which products need updates?" → Browse `products[]` array
- "Which extensions need updates?" → Browse `extensions[]` array
- "What's the fix for System.Text.Json?" → Filter `extensions[]` by name

## Prior art

[CVE Assignment Information Format](https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html) tackles much the same problem.

The vocabulary of the cve.org schema and the proposed one (per this spec) match closely. Key alignments:

- `[CVEID]` maps to our `id` and `cve-id` fields
- `[PRODUCT]` is represented through our `products[]` array and `product-cves` index
- `[VERSION]` is represented in our `products[]` and `extensions[]` version fields
- `[PROBLEMTYPE]` maps to our `problem` field
- `[REFERENCES]` maps to our `references` array
- `[DESCRIPTION]` maps to our `description` array
- `[ASSIGNINGCNA]` maps to our optional `cna` field

That means that interchange should be trivial.

See Appendix for more information on the cve.org format.

## Key Design Decisions

The primary value add of the proposed schema is:

- Normalized structure that reduces duplication (and chance for error).
- Separates high-level CVE description from its applicability (products, extensions, and the version dimension for both).
- Adds commits as a first-class concept, referenced from products and extensions
- Enables limiting CVE applicability to one or more platforms (in contrast to "all").
- Treats queryability and automation as a primary design concern.
- Limit properties that are allowed to be absent or `null` as they complicate queries.

### 1. Arrays vs Dictionaries

Data structures are chosen based on access patterns:

- **Arrays for data (discovery)**: `cves[]`, `products[]`, and `extensions[]` contain the actual CVE and affected component data as arrays because users discover this information rather than knowing it a priori. The naming directly reflects the "products + extensions" model.
- **Dictionaries for indices (lookup)**: `commits{}`, `cve-commits{}`, and `release-cves{}` provide fast lookups for known keys.

"known keys" refers to information that would be known ahead of time (like a version number) or that would be discovered by navigating one of the arrays.

This clear separation - arrays for what happened, dictionaries for finding things - creates a consistent mental model and emphasizes the role of indices as the primary lookup mechanism.

### 2. Normalized Commit Data

Commit details are stored once in a top-level `commits{}` dictionary, with other sections referencing commits by hash.

Benefits:

- Eliminates data duplication
- Ensures consistency
- Reduces file size
- Maintains a single source of truth

#### Commit URL Format – Prefer `.diff` for Tool/LLM Consumption

We intentionally publish commit URLs in their `raw diff` form by appending `.diff` (e.g., `https://github.com/dotnet/runtime/commit/<hash>.diff`). This design choice is based on practical constraints observed with current LLM and automated tooling environments:

- Most hosted LLM services cannot synthesize or mutate outbound URLs (they cannot reliably "add .diff" or alter paths); they can only access URLs explicitly present in the user‑supplied context/files. Surfacing the machine‑optimized form directly ensures the diff is immediately retrievable.
- The GitHub commit HTML view contains significant presentational markup that adds noise for machine processing, while the `.diff` variant provides a concise, structured, line-oriented representation ideal for parsing, summarization, and semantic embedding.
- Relying on clients to “add `.diff` themselves” fails in environments where outbound request mutation is disallowed or brittle.
- Making the data file immediately linkable to machine-friendly content fulfills the schema’s goal of end-to-end automation readiness.

Human-facing tools (web dashboards, docs generators) that prefer the rich HTML commit page can trivially derive it by stripping the trailing `.diff` segment.

Policy:

- All `commits[hash].url` values SHOULD use the `.diff` form.
- Downstream tools MAY normalize to the HTML form by stripping `.diff` for end-user hyperlinks.
- If a hosting forge provides multiple raw formats (e.g., `.patch`), `.diff` is chosen for minimal size and sufficient context; `.patch` includes mail-style headers that only add value for niche analysis.

This pattern exemplifies a broader principle: if a resource is intended to be machine-consumed, publish the machine-optimized representation directly instead of assuming transformation steps the consumer might be unable to perform.

### 3. Two-Layer Denormalization Strategy

The schema employs a two-layer approach to denormalization:

#### Layer 1: Core Data Structure (Flat Arrays)

The fundamental data lives in four structures:

- `cves[]` - The CVE metadata (array)
- `products[]` - Product vulnerabilities (flat, denormalized array)
- `extensions[]` - Extension vulnerabilities (flat, denormalized array)  
- `commits{}` - Commit details (normalized dictionary)

The `products[]` and `extensions[]` arrays intentionally use a flat structure where each entry represents a unique combination of (component + CVE + release). This means a product like ".NET" appears multiple times - once for each vulnerability. This structural denormalization eliminates complex joins at query time.

**Note on terminology**: `release` refers to major.minor version families (e.g., "8.0") that group all patch versions (8.0.0, 8.0.1, 8.0.7, etc.). This aligns with existing .NET release schemas and makes the format reusable by other versioned products. `release` is the same as `channel-version` used in other schemas.

#### Layer 2: Computed Indices (Query Accelerators)

On top of the core data, we provide pre-computed indices that serve as "join as a service":

#### `cve-commits`

Maps CVE IDs to commit hashes:

```json
"cve-commits": {
  "CVE-2024-38095": ["979135d5...", "4a8d5a0..."]
}
```

Enables simple lookup: "Which commits fix this CVE?"

#### `release-cves`

Maps release families to affected CVEs:

```json
"release-cves": {
  "8.0": ["CVE-2024-30105", "CVE-2024-35264", "CVE-2024-38095"]
}
```

Answers: "Which CVEs affect .NET 8.0?" (including products and extensions with `release: "8.0"`)

#### `cve-releases`

Maps CVE IDs to affected release families:

```json
"cve-releases": {
  "CVE-2024-38095": ["6.0", "8.0"]
}
```

Answers: "Which releases are affected by this CVE?" (reverse lookup of release-cves)

#### `product-cves`

Maps product identifiers to CVE IDs:

```json
"product-cves": {
  "dotnet": ["CVE-2024-30105", "CVE-2024-38081", "CVE-2024-38095"],
  "aspnetcore": ["CVE-2024-35264"]
}
```

Answers: "Which CVEs affect product X?"

#### `product-name`

Maps canonical product slugs (used in `products[].name` and related indices) to human-display names. Keys are stable identifiers; values are presentation labels. Consumers SHOULD use the slug for joins and the mapped value for UI.

```json
"product-name": {
  "dotnet": ".NET",
  "aspnetcore": "ASP.NET Core"
}
```

This index serves a different purpose than the others - it's not about relationships but about presentation. Many queries work fine with just the product identifiers (dotnet, aspnetcore), but when generating human-readable reports or markdown tables, this lookup provides the properly formatted names.

### 4. Indices as Extensible Value-Adds

The indices are distinct from the core schema in important ways:

1. **Optional but Valuable**: The core schema (cves, products, extensions, commits) contains all the source data. The indices are computed projections that accelerate common queries. A consumer could use the schema without the indices by computing the lookups themselves.

2. **Extensible by Design**: New indices can be added in a backward-compatible way as new query patterns emerge. For example:
   - `severity-cves`: Map severity levels to CVE lists
   - `date-cves`: Map dates/months to CVEs for temporal queries for cve.json files that describe longer time periods
   - `commit-products`: Map commits to affected products

3. **Implementation Flexibility**: While we provide these indices in the JSON, consumers could:
   - Build them dynamically on ingestion
   - Store them in a database as materialized views
   - Ignore them entirely and query the raw arrays

The indexes are a design tradeoff. The intent of the schema is to provide a fully normalized design (in a relational database sense) and also enable ergonomic `jq` queries. Those were found (unsurprisingly) to be at odds. The calculated indexes tactically break the normalization principle by introducing redundancy, but they transform complex multi-stage joins into simple lookups. Without them, common queries would require nested loops and variable juggling that make both human and LLM consumption difficult. We chose pragmatism over purity - the indices are a small storage compromise (just arrays of IDs) that provide enormous value in query simplicity. They serve as pre-computed views that make the schema actually usable.

### 5. Structural Invariant: Products and Extensions Identity

The `products[]` and `extensions[]` arrays have **identical structure** - every field that exists in one exists in the other with the same meaning and data type. This structural invariant is a key design principle that enables uniform query patterns.

**Common structure:**

- `cve-id`: CVE identifier this entry relates to (primary / foreign key model)
- `name`: Component identifier for lookup and grouping
- `min-vulnerable`, `max-vulnerable`, `fixed`: Version range fields
- `commits`: Array of commit hashes referencing the commits dictionary (optional)
- `release`: Release family like "8.0" (optional for some extensions)

**Query Benefits:**
This identical structure allows queries to treat both arrays uniformly using `[.products[], .extensions[]]` patterns, eliminating the need for separate logic paths or duplicate query code.

**Invariant Maintenance:**
Any new field added to one array must be added to the other (with appropriate defaults/null values where not applicable) to maintain this structural consistency.

Notes:

- The `release` property is optional for extensions that aren't tied to a specific .NET release family (e.g., Microsoft.IO.Redist).
- The `commits` property is optional, but encouraged for open source projects.

### 6. Query Optimization

The schema prioritizes common query patterns:

```bash
# Simple CVE lookup
jq -r '.cves[] | select(.severity == "Critical")'

# Direct version access
jq -r '.products[] | select(.release == "8.0")'

# Clean commit lookups
jq -r '. as $root | .["cve-commits"]["CVE-2024-38095"][] | $root.commits[.].url'
```

### 7. Explicit Value Requirements

The schema avoids null values and implicit assumptions to ensure predictable queries and eliminate ambiguity. All fields that could reasonably have "unknown" or "not applicable" states must instead use explicit values that clearly indicate their meaning.

This design principle simplifies query patterns by eliminating null-handling complexity and prevents different interpretations of missing data.

#### 7.1. Platform Specification

The `platforms` field in CVE entries demonstrates this principle. Rather than allowing implicit "all platforms" assumptions through omitted fields, the schema requires explicit specification:

- **Explicit specification required**: All CVE entries MUST include a `platforms` field
- **Use "All" for cross-platform vulnerabilities**: When a vulnerability affects all supported platforms, use `["All"]` rather than omitting the field  
- **Specific platforms when limited**: Use specific platform names (e.g., `["Windows"]`, `["Linux"]`, `["macOS"]`) when the vulnerability affects only those platforms
- **Multiple specific platforms**: Use arrays like `["Linux", "Windows"]` when affecting multiple but not all platforms

This approach ensures consistent queryability - tools can reliably filter platform-specific CVEs without needing to interpret missing fields as implicit "all platforms" assumptions.

#### 7.2. Release Field Specification

The `release` field in products and extensions entries follows the same principle to simplify query patterns:

- **Always present**: All product and extension entries MUST include a `release` field
- **Empty string for release-independent components**: Extensions not tied to a specific .NET release family use `""` rather than `null`
- **Specific release families**: Use standard release identifiers like `"6.0"`, `"8.0"` for components tied to those releases

**Query simplification example:**

Without this requirement, queries need complex null-handling:

```bash
# Complex: handle both null and empty string cases
jq -r '.extensions[] | select(.release == null or .release == "") | .name'
```

With explicit empty strings:

```bash
# Simple: direct string comparison
jq -r '.extensions[] | select(.release == "") | .name'
```

### 8. Challenges

The schema attempts to offer clear currency for queries, with well-defined primary/foreign key relationships. `cve[].id` is a good example. There are some properties in the schema that don't work as well and may cause problems..

- `products[].name` is a nice token (no spaces) but doesn't define its scope even with the benefit of `product-name` lookups. For monolithic products, this may not be an issue, but for more componentized offerings, it could be.

This property suffers from not knowing the complete set and some accompanying prose to describe any required detail or nuance.

## Schema example

See [cve.json](./cve.json) for a complete example demonstrating all schema features.

## Querying for CVEs -- with `cves` array

The `cves` property exposes an array of CVE objects, documenting the set of CVEs for the month (or disclosure period).

**Note**: The following sections assume the JSON data is saved as `cve.json`.

### Get all CVE IDs

```bash
$ jq -r '.cves[].id' cve.json 
CVE-2024-30105
CVE-2024-35264
CVE-2024-38081
CVE-2024-38095
```

### Get CVEs by severity

```bash
$ jq -r '.cves[] | select(.severity == "Critical") | .id' cve.json
CVE-2024-30105
CVE-2024-35264
CVE-2024-38081
CVE-2024-38095
```

### Get CVE IDs and problems

```bash
$ jq -r '.cves[] | "\(.id): \(.problem)"' cve.json
CVE-2024-30105: .NET Denial of Service Vulnerability
CVE-2024-35264: .NET Remote Code Execution Vulnerability
CVE-2024-38081: .NET Denial of Service Vulnerability
CVE-2024-38095: .NET Denial of Service Vulnerability
```

### Get CVEs affecting specific products

Using the product-cves index:

```bash
$ jq -r '.["product-cves"]["aspnetcore"][]' cve.json
CVE-2024-35264
```

Or to get full CVE details for a product:

```bash
$ jq -r '. as $root | 
  .["product-cves"]["dotnet"][] as $cve | 
  $root.cves[] | select(.id == $cve) | .id' cve.json
CVE-2024-30105
CVE-2024-38081
CVE-2024-38095
```

## Querying for affected releases by release -- with `release-cves` dictionary

The `release-cves` dictionary index exposes the set of CVEs that affect a given release version. Both product and extension objects can be projected into this dictionary, assuming they have a `release` value set.

### Get CVEs for a specific .NET version

```bash
$ jq -r '.["release-cves"]["8.0"][]' cve.json
CVE-2024-30105
CVE-2024-35264
CVE-2024-38095
```

Defensive version (handles missing release):

```bash
$ jq -r '.["release-cves"]["9.0"] // "No CVEs reported"' cve.json
No CVEs reported
```

Note: `//` is similar to `??` in C#. The former applies to any "falsey" value whereas the latter is specific to `null`.

### Count CVEs per version

```bash
$ jq -r '.["release-cves"] | to_entries[] | "\(.key): \(.value | length) CVEs"' cve.json
6.0: 2 CVEs
8.0: 3 CVEs
```

Defensive version (handles missing release):

```bash
$ jq -r '(.["release-cves"]["9.0"] // []) | length' cve.json
0
```

## Querying for affected releases by CVE-ID -- with `cve-releases` dictionary

The `cve-releases` dictionary index exposes the set of releases affected by a given CVE. Both product and extension objects can be projected into this dictionary as keys, assuming they have a `release` value set.

Note: `cve-releases` and `release-cves` are mirrors of one another enabling symmetric bidirectional queries (with the same query cost/complexity).

**Get releases affected by a specific CVE**

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"][]' cve.json
6.0
8.0
```

Defensive version (handles missing CVE):

```bash
$ jq -r '(.["cve-releases"]["CVE-2024-XXXXX"] // [])[]' cve.json
$
```

(No output means CVE not found)

**Get releases affected by multiple CVEs**

```bash
$ jq -r '.["cve-releases"] | to_entries[] | select(.key == "CVE-2024-38095" or .key == "CVE-2024-30105") | "\(.key): \(.value | join(", "))"' cve.json
CVE-2024-30105: 8.0
CVE-2024-38095: 6.0, 8.0
```

**Check if a CVE affects a specific release**

Using the `cve-releases` index (preferred):

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"] | contains(["8.0"])' cve.json
true
```

Or using the `release-cves` index:

```bash
$ jq -r '.["release-cves"]["8.0"] | contains(["CVE-2024-38095"])' cve.json
true
```

The `cve-releases` approach is preferred because the query naturally starts with the CVE (which you typically know) and asks "does it affect this release?" The `release-cves` approach requires flipping the question to "does this release contain this CVE?"

Defensive version (handles missing CVE and/or missing release):

```bash
$ jq -r '(.["cve-releases"]["CVE-2024-XXXXX"] // []) | contains(["8.0"])' cve.json
false
```

This query is defensive against missing CVEs and/or missing releases:

- `// []` handles the case where the CVE doesn't exist in the index (returns empty array)  
- `contains(["8.0"])` safely checks if "8.0" is in the array, returning false for empty arrays

**Get releases affected by a specific CVE**

Using the new `cve-releases` index (preferred):

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"][]' cve.json
6.0
8.0
```

Or using the `release-cves` index:

```bash
$ jq -r '.["release-cves"] | to_entries[] | select(.value[] == "CVE-2024-38095") | .key' cve.json
6.0
8.0
```

## Querying for commits by CVE-ID -- with `cve-commits`

The `cve-commits` dictionary/index exposes the set of commits affected by a given CVE. CVEs are not expected to be known a priori so must be discovered via on the other indexes or via one of the array properties.

**Get commits for a given CVE**

```bash
$ jq -r '. as $root | .["cve-commits"]["CVE-2024-38095"][] | $root.commits[.].url' cve.json
https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a.diff
https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991.diff
```

Defensive version (handles missing CVE):

```bash
$ jq -r '. as $root | (.["cve-commits"]["CVE-2024-XXXXX"] // [])[] | $root.commits[.].url' cve.json
$
```

(No output means CVE not found)

**Get commits for a given release**

```bash
$ jq -r '. as $root | .["release-cves"]["8.0"][] as $cve | $root["cve-commits"][$cve][] | $root.commits[.].url' cve.json
https://github.com/dotnet/runtime/commit/fa5b0d8f4a8b424732cc992158aa92842f8a2846.diff
https://github.com/dotnet/aspnetcore/commit/c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc.diff
https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a.diff
https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991.diff
```

Defensive version (handles missing release):

```bash
$ jq -r '. as $root | (.["release-cves"]["9.0"] // [])[] as $cve | $root["cve-commits"][$cve][] | $root.commits[.].url' cve.json
$
```

(No output means release not found)

**Get CVEs and commits for a given release**

```bash
$ jq -r '. as $root | .["release-cves"]["8.0"][] as $cve | $root["cve-commits"][$cve][] | "\($cve): \($root.commits[.].url)"' cve.json
CVE-2024-30105: https://github.com/dotnet/runtime/commit/fa5b0d8f4a8b424732cc992158aa92842f8a2846.diff
CVE-2024-35264: https://github.com/dotnet/aspnetcore/commit/c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc.diff
CVE-2024-38095: https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a.diff
CVE-2024-38095: https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991.diff
```

## Querying `products` and `extensions` for impact

**Get affected `product` components**

For quick lookups (using product identifiers):

```bash
$ jq -r '.products[] | .name' cve.json | sort -u
aspnetcore
dotnet
```

For human-readable output (using display names):

```bash
$ jq -r '.["product-name"] | to_entries[] | .value' cve.json | sort -u
ASP.NET Core
.NET
```

For affected versions:

```bash
$ jq -r '.products[] | .release' cve.json | sort -u
6.0
8.0
```

Combined view:

```bash
$ jq -r '.products[] | "\(.name): \(.release)"' cve.json | sort -u
aspnetcore: 8.0
dotnet: 6.0
dotnet: 8.0
```

**Get affected `extension` components**

```bash
$ jq -r '.extensions[] | .name' cve.json | sort -u
Microsoft.IO.Redist
System.Formats.Asn1
System.Text.Json
```

For affected versions:

```bash
$ jq -r '.extensions[] | .release' cve.json | sort -u
6.0
8.0
null
```

(Note: `null` appears for extensions without a `release` field, like Microsoft.IO.Redist)

Combined view:

```bash
$ jq -r '.extensions[] | "\(.name): \(.release)"' cve.json | sort -u
Microsoft.IO.Redist: null
System.Formats.Asn1: 6.0
System.Formats.Asn1: 8.0
System.Text.Json: 8.0
```

**Get fixed versions for product components**

```bash
$ jq -r '.products[] | "\(.["cve-id"]): fixed in \(.fixed) (product: \(.name))"' cve.json
CVE-2024-38081: fixed in 6.0.32 (product: dotnet)
CVE-2024-38095: fixed in 6.0.32 (product: dotnet)
CVE-2024-30105: fixed in 8.0.7 (product: dotnet)
CVE-2024-35264: fixed in 8.0.7 (product: aspnetcore)
CVE-2024-38095: fixed in 8.0.7 (product: dotnet)
```

**Get fixed versions for product components for a specific release**

```bash
$ jq -r '.products[] | select(.release == "8.0") | "\(.["cve-id"]): fixed in \(.fixed) (product: \(.name))"' cve.json
CVE-2024-30105: fixed in 8.0.7 (product: dotnet)
CVE-2024-35264: fixed in 8.0.7 (product: aspnetcore)
CVE-2024-38095: fixed in 8.0.7 (product: dotnet)
```

**Get fixed versions for extensions**

```bash
$ jq -r '.extensions[] | "\(.["cve-id"]): fixed in \(.fixed) (extension: \(.name))"' cve.json
CVE-2024-38081: fixed in 6.0.1 (extension: Microsoft.IO.Redist)
CVE-2024-38095: fixed in 6.0.1 (extension: System.Formats.Asn1)
CVE-2024-38095: fixed in 8.0.1 (extension: System.Formats.Asn1)
CVE-2024-30105: fixed in 8.0.4 (extension: System.Text.Json)
```

**Get fixed versions for a specific extension**

```bash
$ jq -r '.extensions[] | select(.name == "System.Text.Json") | "\(.["cve-id"]): fixed in \(.fixed)"' cve.json
CVE-2024-30105: fixed in 8.0.4
```

In case of unaffected (or mispelled) extension:

```bash
$ jq -r '.extensions[] | select(.name == "System.Text.Jason") | "\(.["cve-id"]): fixed in \(.fixed)"' cve.json
$
```

(No output means not affected)

**Extensions with no `release`**

```bash
$ jq -r '.extensions[] | select(.release == "") | .name' cve.json | sort -u
Microsoft.IO.Redist
```

This extension has no relationship to one of the product releases.

## Mega queries

The following queries pull data from multiple nodes to produce high-value summaries. These queries prefer producing markdown tables as output.

**Get CVE details with affected releases**

```bash
$ jq -r '. as $root | 
  (["| CVE ID        | Severity | Releases | Problem |",
    "| ------------- | -------- | -------- | ------- |"] +
   [$root.cves[] | 
    .id as $cve | 
    "| \($cve)  | \(.severity) | \(($root["cve-releases"][$cve] // []) | join(", "))     | \(.problem) |"]) | 
  .[]' cve.json
| CVE ID        | Severity | Releases | Problem |
| ------------- | -------- | -------- | ------- |
| CVE-2024-30105  | Critical | 8.0     | .NET Denial of Service Vulnerability |
| CVE-2024-35264  | Critical | 8.0     | .NET Remote Code Execution Vulnerability |
| CVE-2024-38081  | Critical | 6.0     | .NET Denial of Service Vulnerability |
| CVE-2024-38095  | Critical | 6.0, 8.0     | .NET Denial of Service Vulnerability |
```

**Get all extensions affected by Critical CVEs**

```bash
$ jq -r '. as $root | 
  [$root.cves[] | select(.severity == "Critical") | .id] as $critical_cves |
  (["| CVE ID        | Extension |",
    "| ------------- | --------- |"] +
   [$root.extensions[] | 
    select(.["cve-id"] as $cve | $critical_cves | contains([$cve])) | 
    "| \(.["cve-id"])  | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Extension |
| ------------- | --------- |
| CVE-2024-38081  | Microsoft.IO.Redist |
| CVE-2024-38095  | System.Formats.Asn1 |
| CVE-2024-38095  | System.Formats.Asn1 |
| CVE-2024-30105  | System.Text.Json |
```

**Find CVEs without commit information**

```bash
$ jq -r '[.cves[].id] as $all_cves | 
  [.["cve-commits"] | keys[]] as $with_commits | 
  $all_cves - $with_commits | 
  if length > 0 then "CVEs without commits: " + (. | join(", ")) else "All CVEs have associated commits" end' cve.json
All CVEs have associated commits
```

**Show platform information for all CVEs**

```bash
$ jq -r '(["| CVE ID        | Platforms |",
        "| ------------- | --------- |"] +
       [.cves[] | 
        "| \(.id)  | \(.platforms | join(", ")) |"]) | 
      .[]' cve.json
| CVE ID        | Platforms |
| ------------- | --------- |
| CVE-2024-30105  | All |
| CVE-2024-35264  | All |
| CVE-2024-38081  | Windows |
| CVE-2024-38095  | All |
```

**Extract CVSS availability impact**

Useful for risk assessment and prioritization:

```bash
$ jq -r '. as $root | 
  (["| CVE ID        | Impact | Problem |",
    "| ------------- | ------ | ------- |"] +
   [$root.cves[] | 
    .cvss.uri as $cvss | 
    .id as $id | 
    "| \($id)  | \($cvss | split("/") | .[3:] | map(select(startswith("A:")) | split(":")[1]) | .[0] // "N/A")      | \(.problem) |"]) | 
  .[]' cve.json
| CVE ID        | Impact | Problem |
| ------------- | ------ | ------- |
| CVE-2024-30105  | H      | .NET Denial of Service Vulnerability |
| CVE-2024-35264  | H      | .NET Remote Code Execution Vulnerability |
| CVE-2024-38081  | H      | .NET Denial of Service Vulnerability |
| CVE-2024-38095  | L      | .NET Denial of Service Vulnerability |
```

**Show all components affected by each CVE**

Cross-component impact analysis combining products and extensions:

```bash
$ jq -r '. as $root | 
  [.products[], .extensions[]] | 
  group_by(.["cve-id"]) | 
  (["| CVE ID        | Count | Components |",
    "| ------------- | ----- | ---------- |"] +
   [.[] | 
    "| \(.[0]["cve-id"])  | \([.[] | .name] | unique | length)     | \([.[] | .name] | unique | join(", ")) |"]) | 
  .[]' cve.json
| CVE ID        | Count | Components |
| ------------- | ----- | ---------- |
| CVE-2024-30105  | 2     | System.Text.Json, dotnet |
| CVE-2024-35264  | 1     | aspnetcore |
| CVE-2024-38081  | 2     | Microsoft.IO.Redist, dotnet |
| CVE-2024-38095  | 2     | System.Formats.Asn1, dotnet |
```

**Find components with multiple vulnerabilities**

```bash
$ jq -r '[.products[], .extensions[]] | 
  group_by(.name) | 
  map({name: .[0].name, cves: [.[] | .["cve-id"]] | unique}) | 
  map(select(.cves | length > 1)) |
  (["| Component | CVEs |",
    "| --------- | ---- |"] +
   [.[] | "| \(.name) | \(.cves | join(", ")) |"]) | 
  .[]' cve.json
| Component | CVEs |
| --------- | ---- |
| dotnet | CVE-2024-30105, CVE-2024-38081, CVE-2024-38095 |
```

**Get all patches needed for a release**

For quick reference (using product identifiers):

```bash
$ jq -r '[.products[], .extensions[]] | 
  map(select(.release == "8.0")) | 
  group_by(.name) | 
  map({name: .[0].name, versions: [.[] | .fixed] | unique | sort}) | 
  (["| Version | Component |", "| ------- | --------- |"] + 
  map("| \(.versions | last)   | \(.name) |")) | 
  .[]' cve.json
| Version | Component |
| ------- | --------- |
| 8.0.1   | System.Formats.Asn1 |
| 8.0.4   | System.Text.Json |
| 8.0.7   | aspnetcore |
| 8.0.7   | dotnet |
```

For human-readable reports (with nice names):

```bash
$ jq -r '. as $root |
  [.products[], .extensions[]] | 
  map(select(.release == "8.0")) | 
  group_by(.name) | 
  map({
    id: .[0].name,
    name: ($root["product-name"][.[0].name] // .[0].name),
    versions: [.[] | .fixed] | unique | sort
  }) | 
  (["| Version | Component |", "| ------- | --------- |"] + 
  map("| \(.versions | last)   | \(.name) |")) | 
  .[]' cve.json
| Version | Component |
| ------- | --------- |
| 8.0.7   | ASP.NET Core |
| 8.0.7   | .NET |
| 8.0.1   | System.Formats.Asn1 |
| 8.0.4   | System.Text.Json |
```

**Show release-independent extensions**

Useful for tracking updates to extensions not tied to .NET releases:

```bash
$ jq -r '.extensions[] | 
  select(.release == "") |
  [{cve: .["cve-id"], version: .fixed, name: .name}] |
  (["| CVE ID        | Version | Extension |",
    "| ------------- | ------- | --------- |"] +
   [.[] | "| \(.cve)  | \(.version)    | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Version | Extension |
| ------------- | ------- | --------- |
| CVE-2024-38081  | 6.0.1    | Microsoft.IO.Redist |
```

**Repository-level commit summary**

```bash
$ jq -r '. as $root | 
  .commits | 
  to_entries | 
  group_by(.value.repo) | 
  map({
    repo: .[0].value.repo, 
    commits: [.[] | .key] | length, 
    cves: ([.[] | .key as $hash | $root["cve-commits"] | to_entries[] | select(.value[] == $hash) | .key] | unique | length)
  }) | 
  (["| Repository | Commits | CVEs |",
    "| ---------- | ------- | ---- |"] +
   [.[] | "| \(.repo)  | \(.commits)       | \(.cves)    |"]) | 
  .[]' cve.json
| Repository | Commits | CVEs |
| ---------- | ------- | ---- |
| aspnetcore  | 1       | 1    |
| runtime  | 4       | 3    |
```

**Check if specific version is vulnerable**

```bash
$ jq -r --arg release "8.0" --arg version "8.0.5" '
  [.products[], .extensions[]] | 
  map(select(.release == $release)) |
  map(select(.["min-vulnerable"] <= $version and .["max-vulnerable"] >= $version)) |
  (["| CVE ID        | Component |",
    "| ------------- | --------- |"] +
   [.[] | "| \(.["cve-id"])  | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Component |
| ------------- | --------- |
| CVE-2024-30105  | dotnet |
| CVE-2024-35264  | aspnetcore |
| CVE-2024-38095  | dotnet |
```

## Appendix: Schema Design and Query Tradeoff Analysis

This schema was designed with "queryability as a primary design concern" - optimizing for common security operations workflows over theoretical data modeling purity. This appendix analyzes the key design decisions and their impact on query complexity.

### Design Philosophy: Optimizing for Query Simplicity

The schema employs **strategic denormalization** - intentionally duplicating data to make queries simpler. For example, `System.Formats.Asn1` appears twice in the extensions array - once for each CVE/release combination it's affected by.

This denormalization trades storage efficiency for query simplicity:

- **Normalized approach**: One object per component, nested ranges for different CVEs
- **Denormalized approach**: Separate objects for each CVE/component combination

Since CVE data is queried far more often than it's updated, this trade-off optimizes for the common case of reading and analyzing the data.

### Current Schema vs Alternative Approaches

We evaluated three main approaches:

### 1. Current Schema (Flat Denormalized)

```json
{
  "extensions": [
    {"cve-id": "CVE-2024-38095", "name": "System.Formats.Asn1", "release": "6.0", "fixed": "6.0.1"},
    {"cve-id": "CVE-2024-38095", "name": "System.Formats.Asn1", "release": "8.0", "fixed": "8.0.1"}
  ]
}
```

### 2. Hybrid Schema (Package-Centric with Ranges)

```json
{
  "extensions": [
    {
      "name": "System.Formats.Asn1",
      "ranges": [
        {"cve-id": "CVE-2024-38095", "release": "6.0", "fixed": "6.0.1"},
        {"cve-id": "CVE-2024-38095", "release": "8.0", "fixed": "8.0.1"}
      ]
    }
  ]
}
```

### 3. Ranges Schema (OSV-Style)

```json
{
  "affected": [
    {
      "package": {"name": "System.Formats.Asn1"},
      "ranges": [
        {"type": "ECOSYSTEM", "events": [{"introduced": "6.0.0", "fixed": "6.0.1"}]}
      ]
    }
  ]
}
```

### Query Complexity Analysis

The following table compares query complexity across schemas for common operations:

| Query Pattern | Current Schema | Hybrid Schema | Ranges Schema | Primary Use Case |
|---------------|----------------|---------------|---------------|------------------|
| **CVE → Components** | ✅ Simple filter | ❌ Nested select | ❌ Double nested | **High priority** |
| **Component → CVEs** | ✅ Direct field | ❌ Array traversal | ✅ Direct field | **High priority** |
| **Version vulnerability check** | ✅ Top-level fields | ❌ Nested access | ❌ Event parsing | **High priority** |
| **Release-specific patches** | ✅ Simple filter | ❌ Nested filter | ❌ Complex logic | **Medium priority** |
| **Components with multiple CVEs** | ❌ Group-by needed | ✅ Direct check | ✅ Direct field | **Low priority** |
| **Package deduplication** | ❌ Duplicates exist | ✅ No duplicates | ✅ No duplicates | **Low priority** |

**Result**: Current schema wins 4/6 query patterns, optimizing for the highest-priority security operations.

### Detailed Query Examples

#### "Which components are affected by CVE-2024-38095?"

**Current Schema (Winner):**

```bash
jq -r '[.products[], .extensions[]] | 
  map(select(.["cve-id"] == "CVE-2024-38095")) | 
  .[].name'
```

**Hybrid Schema:**

```bash
jq -r '[.products[], .extensions[]] | 
  map(select(.ranges[]? | .["cve-id"] == "CVE-2024-38095")) | 
  .[].name'
```

**Ranges Schema:**

```bash
jq -r '.affected[] | 
  select(.ranges[] | .events[] | has("cve_id") and .cve_id == "CVE-2024-38095") | 
  .package.name'
```

The current schema requires the simplest filter logic for this critical security operation.

#### "Which components have multiple vulnerabilities?"

**Current Schema:**

```bash
jq -r '[.products[], .extensions[]] | 
  group_by(.name) | 
  map(select(length > 1)) | 
  .[] | "\(.[0].name): \([.[] | .["cve-id"]] | unique | length) CVEs"'
```

**Hybrid Schema (Winner):**

```bash
jq -r '[.products[], .extensions[]] | 
  map(select(.ranges | map(.["cve-id"]) | unique | length > 1)) |
  .[] | "\(.name): \(.ranges | map(.["cve-id"]) | unique | length) CVEs"'
```

The hybrid approach eliminates the need for grouping operations in this less common query.

### Join Indices: Additional Denormalization

The schema includes pre-computed join indices that further optimize queries:

```json
{
  "cve-releases": {
    "CVE-2024-38095": ["6.0", "8.0"]
  },
  "release-cves": {
    "8.0": ["CVE-2024-30105", "CVE-2024-35264", "CVE-2024-38095"]  
  },
  "cve-commits": {
    "CVE-2024-38095": ["979135d5...", "4a8d5a0..."]
  }
}
```

These indices break normalization principles by introducing redundancy, but transform complex multi-stage joins into simple lookups:

**Without Indices:**

```bash
# Find releases affected by a CVE - requires scanning all components
jq -r '[.products[], .extensions[]] | 
  map(select(.["cve-id"] == "CVE-2024-38095")) | 
  map(.release) | unique'
```

**With Indices:**

```bash
# Direct lookup - no scanning required
jq -r '.["cve-releases"]["CVE-2024-38095"][]'
```

### Comparison to Industry Standards

### OSV Schema

The [OSV Schema](https://ossf.github.io/osv-schema/) prioritizes package-centric operations:

- **Strength**: Natural for dependency scanning tools
- **Weakness**: Complex for CVE-centric security analysis  
- **Best for**: Software composition analysis workflows

### CVE.org JSON Format  

If the [CVE Assignment Information Format](https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html) were JSON:

- **Strength**: CVE-centric structure matches security workflows
- **Weakness**: No structured component/version relationships
- **Best for**: Vulnerability disclosure and tracking

### Our Schema

Bridges both approaches:

- **CVE metadata**: Separate for disclosure workflows  
- **Component impact**: Denormalized for analysis workflows
- **Join indices**: Pre-computed for common cross-cutting queries
- **Best for**: Security operations and patch management

### Storage vs Query Performance Trade-offs

| Aspect | Current Schema | Alternative Approaches |
|--------|----------------|----------------------|
| **File size** | ~15% larger due to duplication | Smaller, more normalized |
| **Query complexity** | Simple for 80% of use cases | Complex for common operations |
| **Parse performance** | Fast (flat structure) | Slower (nested traversal) |
| **Maintainability** | Indices require updates | Single source of truth |
| **LLM consumption** | Optimized (simple patterns) | Harder to process |

### Design Validation Through Testing

We validated this design by implementing actual `jq` queries for all documented use cases. The principle was: **"If the `jq` queries look bad, the schema is bad."**

Key findings:

- Simple queries = better human comprehension
- Simple queries = better LLM processing  
- Flat structures = faster parsing
- Pre-computed indices = predictable performance

### Conclusion

The current schema prioritizes **queryability over normalization** because:

1. **Access patterns** are heavily read-biased and CVE-centric
2. **Query simplicity** directly impacts adoption and tooling
3. **Storage cost** of duplication is negligible compared to query complexity cost
4. **Performance predictability** matters more than theoretical efficiency

This represents a **pragmatic over pure** approach - choosing usability over textbook normalization principles.

The small storage overhead buys significant simplification in the queries that security teams run daily, making this a worthwhile trade-off for a security-focused analytical schema.

## Appendix -- CVE Assignment Information Format

From: <https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html>

```text
Where applicable, make use of industry standards when describing vulnerabilities.

[PRODUCT]

As a general guideline, [PRODUCT] should include the vendor, developer, or project name as well as the name of the actual software or hardware in which the vulnerability exists.

[VERSION]

[VERSION] should include the version, date of release, or whatever indicator that is used by vendors, developers, or projects to differentiate between releases. [VERSION] can be described with specific version numbers, ranges of versions, or “all versions before/after” a version number or date.

[PROBLEMTYPE]

As mentioned above, [PROBLEMTYPE] can include an arbitrary summary of the problem, though Common Weakness Enumerations (CWEs) are an excellent standard to use in this field.

[REFERENCES]

[REFERENCES] should be URLs pointing to a world-wide-web-based resource. For CSV and flat-file formats, they should be separated by a space. References should point to content that is relevant to the vulnerability and include at least all the details included in the CVE entry. Ideally, references should point to content that includes the CVE ID itself whenever possible. References must also be publicly available, as described in Section 2.1.1 of the CVE Numbering Authorities (CNA) Rules.

[DESCRIPTION]

The [DESCRIPTION] field is a plain language field that should describe the vulnerability with sufficient detail as to demonstrate that the vulnerability is unique. The required information listed above should be included in the [DESCRIPTION], as well as other details the author feels are relevant or necessary to show uniqueness.

Specifically, the [DESCRIPTION] field could also include:

An explanation of an attack type using the vulnerability;
The impact of the vulnerability;
The software components within a software product that are affected by the vulnerability; and
Any attack vectors that can make use of the vulnerability.
Descriptions often follow this template:

     [PROBLEM TYPE] in [PRODUCT/VERSION] causes [IMPACT] when [ATTACK]

where impact and attack are arbitrary terms that should be relevant to the nature of the vulnerability.

[ASSIGNINGCNA]

The [ASSIGNINGCNA] field should include the name of the assigning CNA. CNAs should use a consistent name to facilitate searches for CVE IDs that originate from them.

Correctly Formatted Example
Following is an example of the reporting format in use. In this case, the Sub-CNA “BigCompanySoft” is assigning a CVE ID to versions of their product.

[CVEID]: CVE-2016-123455
[PRODUCT]: BIGCOMPANYSOFT SOFTWARE PRODUCT
[VERSION]: All versions prior to version 2.5
[PROBLEMTYPE]: Arbitrary Code Execution
[REFERENCES]: http://bigcompanysoft.com/vuln/v1232.html
[DESCRIPTION]: CoreGraphics in BIGCOMPANYSOFT SOFTWARE PRODUCT before 2.5 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted BMP image.
[ASSIGNINGCNA]: BigCompanySoft
```

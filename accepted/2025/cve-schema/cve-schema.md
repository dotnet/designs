# Publishing CVE information as structured data

We publish vulnerability fixes and matching CVE documentation nearly every month. These are primarily [documented on GitHub in HTML](https://github.com/dotnet/announcements/issues?q=is%3Aissue%20state%3Aopen%20label%3ASecurity) for people to read. It is well understood that HTML is a presentation format and not appropriate for structured processing. We intend to offer CVE information in structured JSON format (and likely markdown, too).

This schema has been designed around a "core + extensions" model that reflects how many modern software platforms are structured - with core product components and an ecosystem of extensions. This pattern is prevalent across the industry (editors with extensions, runtimes with packages, apps with plugins), making this schema broadly applicable beyond its initial .NET use case. The design intentionally avoids product-specific terminology to support reuse by other offerings with similar security disclosure needs.

We've taken a significant departure with this schema design, battle-testing it with `jq` and some other tools as part of the development process. If the `jq` queries look bad, the schema is bad. We've also noticed in this new age that `jq` query ease is a proxy for LLM consumption ease. Great `jq` use will likely lead to good or better LLM consumption while bad `jq` queryability will likely lead to bad or worse LLM consumption. We intend to design all schema this way going forward.

This new CVE format will be part of a larger queryable information graph that we'll document soon. For now, we'll focus on the CVE format.

## Quick pitch

Common queries answered by this schema:

- "Which CVEs were reported this month?" → `.cves[].id`
- "Which CVEs affect .NET 8.0?" → `release-cves["8.0"]`
- "Which commits fix CVE-2024-38095?" → `cve-commits["CVE-2024-38095"]`
- "Which extensions need updates?" → Browse `extensions[]` array
- "What's the fix for System.Text.Json?" → Filter `extensions[]` by name

## Prior art

[CVE Assignment Information Format](https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html) is tackling much the same problem.

The vocabulary of the cve.org schema and the proposed one (per this spec) match closely. Key alignments:

- `[CVEID]` maps to our `id` and `cve-id` fields
- `[PRODUCT]` maps to our `product` field
- `[VERSION]` is represented in our `core[]` and `extensions[]` version fields
- `[PROBLEMTYPE]` maps to our `problem` field
- `[REFERENCES]` maps to our `references` array
- `[DESCRIPTION]` maps to our `description` array
- `[ASSIGNINGCNA]` maps to our optional `cna` field

That means that interchange should be trivial.

See Appendix for more information on the cve.org format.

## Key Design Decisions

The primary value add of the proposed schema is:

- Normalized structure that reduces duplication (and chance for error).
- Separates high-level CVE description from its applicability (core, extensions, and the version dimension for both).
- Adds commits as a first-class concept, referenced from core and extensions
- Enables limiting CVE applicability to one or more platforms (in contrast to "all").
- Treats queryability and automation as a primary design concern.

### 1. Arrays vs Dictionaries

Data structures are chosen based on access patterns:

- **Arrays for data (discovery)**: `cves[]`, `core[]`, and `extensions[]` contain the actual CVE and affected component data as arrays because users discover this information rather than knowing it a priori. The naming directly reflects the "core + extensions" model.
- **Dictionaries for indices (lookup)**: `commits{}`, `cve-commits{}`, and `release-cves{}` provide fast lookups for known keys.

"known keys" refers to information that would be known ahead of time (like a version number) or that would be discovered by navigating one of the arrays.

This clear separation - arrays for what happened, dictionaries for finding things - creates a consistent mental model and emphasizes the role of indices as the primary lookup mechanism.

### 2. Normalized Commit Data

Commit details are stored once in a top-level `commits{}` dictionary, with other sections referencing commits by hash.

Benefits:

- Eliminates data duplication
- Ensures consistency
- Reduces file size
- Maintains a single source of truth

### 3. Join Indices

Two "join as a service" indices are provided to simplify common queries:

#### `cve-commits`

Maps CVE IDs to commit hashes:

```json
"cve-commits": {
  "CVE-2024-38095": ["979135d5...", "4a8d5a0..."]
}
```

Enables simple lookup: "Which commits fix this CVE?"

#### `release-cves`

Maps release families to affected CVEs:

```json
"release-cves": {
  "8.0": ["CVE-2024-30105", "CVE-2024-35264", "CVE-2024-38095"]
}
```

Answers: "Which CVEs affect .NET 8.0?" (including core and extensions with `release: "8.0"`)

#### `cve-releases`

Maps CVE IDs to affected release families:

```json
"cve-releases": {
  "CVE-2024-38095": ["6.0", "8.0"]
}
```

Answers: "Which releases are affected by this CVE?" (reverse lookup of release-cves)

**Note on terminology**: `release` refers to major.minor version families (e.g., "8.0") that group all patch versions (8.0.0, 8.0.1, 8.0.7, etc.). This aligns with existing .NET release schemas and makes the format reusable by other versioned products. `release` is the same as `channel-version` used in other schemas.

The indexes are a design tradeoff. The intent of the schema is to provide a fully normalized design (in a relational database sense) and also enable ergonomic `jq` queries. Those were found (unsurprisingly) to be at odds. The calculated indexes break the normalization principle by introducing redundancy, but they transform complex multi-stage joins into simple lookups. Without them, common queries would require nested loops and variable juggling that make both human and LLM consumption difficult. We chose pragmatism over purity - the indices are a small storage compromise (just arrays of IDs) that provide enormous value in query simplicity. They serve as pre-computed views that make the schema actually usable. 

### 4. Consistent Structure

All data arrays (`cves[]`, `core[]`, `extensions[]`) share consistent patterns, with the core/extensions split directly mapping to the "core + extensions" model:

- Each entry is self-contained with all necessary fields
- `name`: Component/extension name for identification
- `commits`: Array of commit hashes referencing the commits dictionary
- Standard version range fields (`min-vulnerable`, `max-vulnerable`, `fixed`)

Notes:

- The `release` property is optional for extensions that aren't tied to a specific .NET release family (e.g., Microsoft.IO.Redist).
- The `commits` property is optional, but encouraged for open source projects.

### 6. Query Optimization

The schema prioritizes common query patterns:

```bash
# Simple CVE lookup
jq -r '.cves[] | select(.severity == "Critical")'

# Direct version access
jq -r '.core[] | select(.release == "8.0")'

# Clean commit lookups
jq -r '. as $root | .["cve-commits"]["CVE-2024-38095"][] | $root.commits[.].url'
```

## Schema example

```json
{
  "date": "2024-07-09",
  "cves": [
    {
      "id": "CVE-2024-30105",
      "problem": ".NET Denial of Service Vulnerability",
      "severity": "Critical",
      "cvss": {"version": "3.1", "uri": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H/E:U/RL:O/RC:C"},
      "description": [
        "A vulnerability exists in .NET when calling the JsonSerializer.DeserializeAsyncEnumerable method against an untrusted input using System.Text.Json may result in Denial of Service."
      ],
      "product": ".NET",
      "cna": "Microsoft",
      "references": [
        "https://github.com/dotnet/announcements/issues/315"
      ]
    },
    {
      "id": "CVE-2024-35264",
      "problem": ".NET Remote Code Execution Vulnerability",
      "severity": "Critical",
      "cvss": {"version": "3.1", "uri": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C"},
      "description": [
        "A Vulnerability exists in ASP.NET Core 8 where Data Corruption in Kestrel HTTP/3 can result in remote code execution.",
        "Note: HTTP/3 is experimental in .NET 6.0. If you are on .NET 6.0 and using HTTP/3, please upgrade to .NET 8.0.7"
      ],
      "product": "ASP.NET Core",
      "references": [
        "https://github.com/dotnet/announcements/issues/314"
      ]
    },
    {
      "id": "CVE-2024-38081",
      "problem": ".NET Denial of Service Vulnerability",
      "severity": "Critical",
      "cvss": {"version": "3.1", "uri": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H/E:U/RL:O/RC:C"},
      "description": [
        "A vulnerability exists in Visual Studio installer on Windowswhere an unprivileged user is allowed to manipulate the Visual Studio installation resulting in elevation of privilege."
      ],
      "product": ".NET",
      "platforms": [
        "Windows"
      ],
      "references": [
        "https://github.com/dotnet/announcements/issues/313"
      ]
    },
    {
      "id": "CVE-2024-38095",
      "problem": ".NET Denial of Service Vulnerability",
      "severity": "Critical",
      "cvss": {"version": "3.1", "uri": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L/E:U/RL:O/RC:C"},
      "description": [
        "A vulnerability exists when System.Formats.Asn1 in .NET parses an X.509 certificate or collection of certificates, a malicious certificate can result in excessive CPU consumption on all platforms result in Denial of Service."
      ],
      "product": ".NET",
      "references": [
        "https://github.com/dotnet/announcements/issues/312"
      ]
    }
  ],
  "core": [
    {
      "cve-id": "CVE-2024-38081",
      "name": "Microsoft.NETCore.App.Runtime",
      "min-vulnerable": "6.0.0",
      "max-vulnerable": "6.0.31",
      "fixed": "6.0.32",
      "release": "6.0",
      "commits": [
        "0a0dd0e27560e692e11ee286ed9f45471b2131fa"
      ]
    },
    {
      "cve-id": "CVE-2024-38095",
      "name": "Microsoft.NETCore.App.Runtime",
      "min-vulnerable": "6.0.0",
      "max-vulnerable": "6.0.31",
      "fixed": "6.0.32",
      "release": "6.0",
      "commits": [
        "979135d5ca4efaf6436ee13539cc3f1e039d570a"
      ]
    },
    {
      "cve-id": "CVE-2024-30105",
      "name": "Microsoft.NETCore.App.Runtime",
      "min-vulnerable": "8.0.0",
      "max-vulnerable": "8.0.6",
      "fixed": "8.0.7",
      "release": "8.0",
      "commits": [
        "fa5b0d8f4a8b424732cc992158aa92842f8a2846"
      ]
    },
    {
      "cve-id": "CVE-2024-35264",
      "name": "Microsoft.AspNetCore.App.Runtime",
      "min-vulnerable": "8.0.0",
      "max-vulnerable": "8.0.6",
      "fixed": "8.0.7",
      "release": "8.0",
      "commits": [
        "c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc"
      ]
    },
    {
      "cve-id": "CVE-2024-38095",
      "name": "Microsoft.NETCore.App.Runtime",
      "min-vulnerable": "8.0.0",
      "max-vulnerable": "8.0.6",
      "fixed": "8.0.7",
      "release": "8.0",
      "commits": [
        "4a8d5a007971d19f389ca17f7b8eb4f9bb199991"
      ]
    }
  ],
  "extensions": [
    {
      "cve-id": "CVE-2024-38081",
      "name": "Microsoft.IO.Redist",
      "min-vulnerable": "4.6.0-preview.18571.3",
      "max-vulnerable": "6.0.0",
      "fixed": "6.0.1",
      "commits": [
        "0a0dd0e27560e692e11ee286ed9f45471b2131fa"
      ]
    },
    {
      "cve-id": "CVE-2024-38095",
      "name": "System.Formats.Asn1",
      "min-vulnerable": "5.0.0-preview.7.20364.11",
      "max-vulnerable": "6.0.0",
      "fixed": "6.0.1",
      "release": "6.0",
      "commits": [
        "979135d5ca4efaf6436ee13539cc3f1e039d570a"
      ]
    },
    {
      "cve-id": "CVE-2024-38095",
      "name": "System.Formats.Asn1",
      "min-vulnerable": "7.0.0-preview.1.22076.8",
      "max-vulnerable": "8.0.0",
      "fixed": "8.0.1",
      "release": "8.0",
      "commits": [
        "4a8d5a007971d19f389ca17f7b8eb4f9bb199991"
      ]
    },
    {
      "cve-id": "CVE-2024-30105",
      "name": "System.Text.Json",
      "min-vulnerable": "8.0.0",
      "max-vulnerable": "8.0.3",
      "fixed": "8.0.4",
      "release": "8.0",
      "commits": [
        "fa5b0d8f4a8b424732cc992158aa92842f8a2846"
      ]
    }
  ],
  "commits": {
    "fa5b0d8f4a8b424732cc992158aa92842f8a2846": {
      "repo": "runtime",
      "branch": "release/8.0",
      "hash": "fa5b0d8f4a8b424732cc992158aa92842f8a2846",
      "org": "dotnet",
      "url": "https://github.com/dotnet/runtime/commit/fa5b0d8f4a8b424732cc992158aa92842f8a2846"
    },
    "c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc": {
      "repo": "aspnetcore",
      "branch": "release/8.0",
      "hash": "c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc",
      "org": "dotnet",
      "url": "https://github.com/dotnet/aspnetcore/commit/c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc"
    },
    "0a0dd0e27560e692e11ee286ed9f45471b2131fa": {
      "repo": "runtime",
      "branch": "release/6.0",
      "hash": "0a0dd0e27560e692e11ee286ed9f45471b2131fa",
      "org": "dotnet",
      "url": "https://github.com/dotnet/runtime/commit/0a0dd0e27560e692e11ee286ed9f45471b2131fa"
    },
    "4a8d5a007971d19f389ca17f7b8eb4f9bb199991": {
      "repo": "runtime",
      "branch": "release/8.0",
      "hash": "4a8d5a007971d19f389ca17f7b8eb4f9bb199991",
      "org": "dotnet",
      "url": "https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991"
    },
    "979135d5ca4efaf6436ee13539cc3f1e039d570a": {
      "repo": "runtime",
      "branch": "release/6.0",
      "hash": "979135d5ca4efaf6436ee13539cc3f1e039d570a",
      "org": "dotnet",
      "url": "https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a"
    }
  },
  "cve-commits": {
      "CVE-2024-30105": ["fa5b0d8f4a8b424732cc992158aa92842f8a2846"],
      "CVE-2024-35264": ["c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc"],
      "CVE-2024-38081": ["0a0dd0e27560e692e11ee286ed9f45471b2131fa"],
      "CVE-2024-38095": ["979135d5ca4efaf6436ee13539cc3f1e039d570a", "4a8d5a007971d19f389ca17f7b8eb4f9bb199991"]
    },
  "cve-releases": {
      "CVE-2024-30105": ["8.0"],
      "CVE-2024-35264": ["8.0"],
      "CVE-2024-38081": ["6.0"],
      "CVE-2024-38095": ["6.0", "8.0"]
    },
  "release-cves": {
    "6.0": ["CVE-2024-38081", "CVE-2024-38095"],
    "8.0": ["CVE-2024-30105", "CVE-2024-35264", "CVE-2024-38095"]
  }
}
```

## Querying for CVEs -- with `cves` array

The `cves` property exposes an array of CVE objects, documenting the set of CVEs for the month (or disclosure period).

**Note**: The following sections assume the JSON data is saved as `cve.json`.

### Get all CVE IDs:

```bash
$ jq -r '.cves[].id' cve.json 
CVE-2024-30105
CVE-2024-35264
CVE-2024-38081
CVE-2024-38095
```

### Get CVEs by severity

```bash
$ jq -r '.cves[] | select(.severity == "Critical") | .id' cve.json
CVE-2024-30105
CVE-2024-35264
CVE-2024-38081
CVE-2024-38095
```

### Get CVE IDs and problems

```bash
$ jq -r '.cves[] | "\(.id): \(.problem)"' cve.json
CVE-2024-30105: .NET Denial of Service Vulnerability
CVE-2024-35264: .NET Remote Code Execution Vulnerability
CVE-2024-38081: .NET Denial of Service Vulnerability
CVE-2024-38095: .NET Denial of Service Vulnerability
```

### Get CVEs affecting specific products

```bash
$ jq -r '.cves[] | select(.product == "ASP.NET Core") | .id' cve.json
CVE-2024-35264
```

Note: Open question on whether product names should be open ended strings if we encourage them to be used as search parameters. It's probably OK and not immediately obvious what a solution would look like.

## Querying for affected releases by release -- with `release-cves` dictionary

The `release-cves` dictionary index exposes the set of CVEs that affect a given release version. Both core and extension objects can be projected into this dictionary, assuming they have a `release` value set.

### Get CVEs for a specific .NET version

```bash
$ jq -r '.["release-cves"]["8.0"][]' cve.json
CVE-2024-30105
CVE-2024-35264
CVE-2024-38095
```

Defensive version (handles missing release):
```bash
$ jq -r '.["release-cves"]["9.0"] // "No CVEs reported"' cve.json
No CVEs reported
```

Note: `//` is similar to `??` in C#. The former applies to any "falsey" value whereas the latter is specific to `null`.

### Count CVEs per version

```bash
$ jq -r '.["release-cves"] | to_entries[] | "\(.key): \(.value | length) CVEs"' cve.json
6.0: 2 CVEs
8.0: 3 CVEs
```

Defensive version (handles missing release):
```bash
$ jq -r '(.["release-cves"]["9.0"] // []) | length' cve.json
0
```

## Querying for affected releases by CVE-ID -- with `cve-releases` dictionary

The `cve-releases` dictionary index exposes the set of releases affected by a given CVE. Both core and extension objects can be projected into this dictionary as keys, assuming they have a `release` value set.

Note: `cve-releases` and `release-cves` are mirrors of one another enabling symmetric bidirectional queries (with the same query cost/complexity).

#### Get releases affected by a specific CVE

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"][]' cve.json
6.0
8.0
```

Defensive version (handles missing CVE):
```bash
$ jq -r '(.["cve-releases"]["CVE-2024-XXXXX"] // [])[]' cve.json
$
```
(No output means CVE not found)

#### Get releases affected by multiple CVEs

```bash
$ jq -r '.["cve-releases"] | to_entries[] | select(.key == "CVE-2024-38095" or .key == "CVE-2024-30105") | "\(.key): \(.value | join(", "))"' cve.json
CVE-2024-30105: 8.0
CVE-2024-38095: 6.0, 8.0
```

#### Check if a CVE affects a specific release

Using the `cve-releases` index (preferred):

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"] | contains(["8.0"])' cve.json
true
```

Or using the `release-cves` index:

```bash
$ jq -r '.["release-cves"]["8.0"] | contains(["CVE-2024-38095"])' cve.json
true
```

The `cve-releases` approach is preferred because the query naturally starts with the CVE (which you typically know) and asks "does it affect this release?" The `release-cves` approach requires flipping the question to "does this release contain this CVE?"

Defensive version (handles missing CVE and/or missing release):
```bash
$ jq -r '(.["cve-releases"]["CVE-2024-XXXXX"] // []) | contains(["8.0"])' cve.json
false
```

This query is defensive against missing CVEs and/or missing releases:

- `// []` handles the case where the CVE doesn't exist in the index (returns empty array)  
- `contains(["8.0"])` safely checks if "8.0" is in the array, returning false for empty arrays

#### Get releases affected by a specific CVE

Using the new `cve-releases` index (preferred):

```bash
$ jq -r '.["cve-releases"]["CVE-2024-38095"][]' cve.json
6.0
8.0
```

Or using the `release-cves` index:

```bash
$ jq -r '.["release-cves"] | to_entries[] | select(.value[] == "CVE-2024-38095") | .key' cve.json
6.0
8.0
```

## Querying for commits by CVE-ID -- with `cve-commits`

The `cve-commits` dictionary/index exposes the set of commits affected by a given CVE. CVEs are not expected to be known a priori so must be discovered via on the other indexes or via one of the array properties.

#### Get commits for a given CVE

```bash
$ jq -r '. as $root | .["cve-commits"]["CVE-2024-38095"][] | $root.commits[.].url' cve.json
https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a
https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991
```

Defensive version (handles missing CVE):
```bash
$ jq -r '. as $root | (.["cve-commits"]["CVE-2024-XXXXX"] // [])[] | $root.commits[.].url' cve.json
$
```
(No output means CVE not found)

#### Get commits for a given release

```bash
$ jq -r '. as $root | .["release-cves"]["8.0"][] as $cve | $root["cve-commits"][$cve][] | $root.commits[.].url' cve.json
https://github.com/dotnet/runtime/commit/fa5b0d8f4a8b424732cc992158aa92842f8a2846
https://github.com/dotnet/aspnetcore/commit/c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc
https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a
https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991
```

Defensive version (handles missing release):
```bash
$ jq -r '. as $root | (.["release-cves"]["9.0"] // [])[] as $cve | $root["cve-commits"][$cve][] | $root.commits[.].url' cve.json
$
```
(No output means release not found)

#### Get CVEs and commits for a given release

```bash
$ jq -r '. as $root | .["release-cves"]["8.0"][] as $cve | $root["cve-commits"][$cve][] | "\($cve): \($root.commits[.].url)"' cve.json
CVE-2024-30105: https://github.com/dotnet/runtime/commit/fa5b0d8f4a8b424732cc992158aa92842f8a2846
CVE-2024-35264: https://github.com/dotnet/aspnetcore/commit/c5721fb7a65ddc13d1b445c2c08c27b72ab57cdc
CVE-2024-38095: https://github.com/dotnet/runtime/commit/979135d5ca4efaf6436ee13539cc3f1e039d570a
CVE-2024-38095: https://github.com/dotnet/runtime/commit/4a8d5a007971d19f389ca17f7b8eb4f9bb199991
```

## Querying `core` and `extensions` for impact

#### Get affected `core` components

```bash
$ jq -r '.core[] | .name' cve.json | sort -u
Microsoft.AspNetCore.App.Runtime
Microsoft.NETCore.App.Runtime
```

For affected versions:

```bash
$ jq -r '.core[] | .release' cve.json | sort -u
6.0
8.0
```

Combined view:

```bash
$ jq -r '.core[] | "\(.name): \(.release)"' cve.json | sort -u
Microsoft.AspNetCore.App.Runtime: 8.0
Microsoft.NETCore.App.Runtime: 6.0
Microsoft.NETCore.App.Runtime: 8.0
```

#### Get affected `extension` components

```bash
$ jq -r '.extensions[] | .name' cve.json | sort -u
Microsoft.IO.Redist
System.Formats.Asn1
System.Text.Json
```

For affected versions:

```bash
$ jq -r '.extensions[] | .release' cve.json | sort -u
6.0
8.0
null
```

Combined view:

```bash
$ jq -r '.extensions[] | "\(.name): \(.release)"' cve.json | sort -u
Microsoft.IO.Redist: null
System.Formats.Asn1: 6.0
System.Formats.Asn1: 8.0
System.Text.Json: 8.0
```

#### Get fixed versions for core components

```bash
$ jq -r '.core[] | "\(.["cve-id"]): fixed in \(.fixed) (core: \(.name))"' cve.json
CVE-2024-38081: fixed in 6.0.32 (core: Microsoft.NETCore.App.Runtime)
CVE-2024-38095: fixed in 6.0.32 (core: Microsoft.NETCore.App.Runtime)
CVE-2024-30105: fixed in 8.0.7 (core: Microsoft.NETCore.App.Runtime)
CVE-2024-35264: fixed in 8.0.7 (core: Microsoft.AspNetCore.App.Runtime)
CVE-2024-38095: fixed in 8.0.7 (core: Microsoft.NETCore.App.Runtime)
```

#### Get fixed versions for core components for a specific release

```bash
$ jq -r '.core[] | select(.release == "8.0") | "\(.["cve-id"]): fixed in \(.fixed) (core: \(.name))"' cve.json
CVE-2024-30105: fixed in 8.0.7 (core: Microsoft.NETCore.App.Runtime)
CVE-2024-35264: fixed in 8.0.7 (core: Microsoft.AspNetCore.App.Runtime)
CVE-2024-38095: fixed in 8.0.7 (core: Microsoft.NETCore.App.Runtime)
```

#### Get fixed versions for extensions

```bash
$ jq -r '.extensions[] | "\(.["cve-id"]): fixed in \(.fixed) (extension: \(.name))"' cve.json
CVE-2024-38081: fixed in 6.0.1 (extension: Microsoft.IO.Redist)
CVE-2024-38095: fixed in 6.0.1 (extension: System.Formats.Asn1)
CVE-2024-38095: fixed in 8.0.1 (extension: System.Formats.Asn1)
CVE-2024-30105: fixed in 8.0.4 (extension: System.Text.Json)
```

#### Get fixed versions for a specific extension

```bash
$ jq -r '.extensions[] | select(.name == "System.Text.Json") | "\(.["cve-id"]): fixed in \(.fixed)"' cve.json
CVE-2024-30105: fixed in 8.0.4
```

In case of unaffected (or mispelled) extension:

```bash
$ jq -r '.extensions[] | select(.name == "System.Text.Jason") | "\(.["cve-id"]): fixed in \(.fixed)"' cve.json
$
```
(No output means not affected)

#### Extensions with no `release`

```bash
$ jq -r '.extensions[] | select(.release == null or .release == "") | .name' cve.json | sort -u
Microsoft.IO.Redist
```

This extension has no relationship to one of the `core` releases.

## Mega queries

The following queries pull data from multiple nodes to produce high-value summaries. These queries prefer producing markdown tables as output.

#### Get CVE details with affected releases

```bash
$ jq -r '. as $root | 
  (["| CVE ID        | Severity | Releases | Problem |",
    "| ------------- | -------- | -------- | ------- |"] +
   [$root.cves[] | 
    .id as $cve | 
    "| \($cve)  | \(.severity) | \(($root["cve-releases"][$cve] // []) | join(", "))     | \(.problem) |"]) | 
  .[]' cve.json
| CVE ID        | Severity | Releases | Problem |
| ------------- | -------- | -------- | ------- |
| CVE-2024-30105  | Critical | 8.0     | .NET Denial of Service Vulnerability |
| CVE-2024-35264  | Critical | 8.0     | .NET Remote Code Execution Vulnerability |
| CVE-2024-38081  | Critical | 6.0     | .NET Denial of Service Vulnerability |
| CVE-2024-38095  | Critical | 6.0, 8.0     | .NET Denial of Service Vulnerability |
```

#### Get all extensions affected by Critical CVEs

```bash
$ jq -r '. as $root | 
  [$root.cves[] | select(.severity == "Critical") | .id] as $critical_cves |
  (["| CVE ID        | Extension |",
    "| ------------- | --------- |"] +
   [$root.extensions[] | 
    select(.["cve-id"] as $cve | $critical_cves | contains([$cve])) | 
    "| \(.["cve-id"])  | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Extension |
| ------------- | --------- |
| CVE-2024-38081  | Microsoft.IO.Redist |
| CVE-2024-38095  | System.Formats.Asn1 |
| CVE-2024-38095  | System.Formats.Asn1 |
| CVE-2024-30105  | System.Text.Json |
```

#### Find CVEs without commit information

```bash
$ jq -r '[.cves[].id] as $all_cves | 
  [.["cve-commits"] | keys[]] as $with_commits | 
  $all_cves - $with_commits | 
  if length > 0 then "CVEs without commits: " + (. | join(", ")) else "All CVEs have associated commits" end' cve.json
All CVEs have associated commits
```

#### Show platform-specific vulnerabilities

```bash
$ jq -r '(["| CVE ID        | Platforms |",
        "| ------------- | --------- |"] +
       [.cves[] | select(.platforms) | 
        "| \(.id)  | \(.platforms | join(", ")) |"]) | 
      .[]' cve.json
| CVE ID        | Platforms |
| ------------- | --------- |
| CVE-2024-38081  | Windows |
```

#### Extract CVSS availability impact

Useful for risk assessment and prioritization:
```bash
$ jq -r '. as $root | 
  (["| CVE ID        | Impact | Problem |",
    "| ------------- | ------ | ------- |"] +
   [$root.cves[] | 
    .cvss.uri as $cvss | 
    .id as $id | 
    "| \($id)  | \($cvss | split("/") | .[3:] | map(select(startswith("A:")) | split(":")[1]) | .[0] // "N/A")      | \(.problem) |"]) | 
  .[]' cve.json
| CVE ID        | Impact | Problem |
| ------------- | ------ | ------- |
| CVE-2024-30105  | H      | .NET Denial of Service Vulnerability |
| CVE-2024-35264  | H      | .NET Remote Code Execution Vulnerability |
| CVE-2024-38081  | H      | .NET Denial of Service Vulnerability |
| CVE-2024-38095  | L      | .NET Denial of Service Vulnerability |
```

#### Show all components affected by each CVE

Cross-component impact analysis combining core and extensions:
```bash
$ jq -r '. as $root | 
  [.core[], .extensions[]] | 
  group_by(.["cve-id"]) | 
  (["| CVE ID        | Count | Components |",
    "| ------------- | ----- | ---------- |"] +
   [.[] | 
    "| \(.[0]["cve-id"])  | \([.[] | .name] | unique | length)     | \([.[] | .name] | unique | join(", ")) |"]) | 
  .[]' cve.json
| CVE ID        | Count | Components |
| ------------- | ----- | ---------- |
| CVE-2024-30105  | 2     | Microsoft.NETCore.App.Runtime, System.Text.Json |
| CVE-2024-35264  | 1     | Microsoft.AspNetCore.App.Runtime |
| CVE-2024-38081  | 2     | Microsoft.IO.Redist, Microsoft.NETCore.App.Runtime |
| CVE-2024-38095  | 2     | Microsoft.NETCore.App.Runtime, System.Formats.Asn1 |
```

#### Find components with multiple vulnerabilities

```bash
$ jq -r '[.core[], .extensions[]] | 
  group_by(.name) | 
  map({name: .[0].name, cves: [.[] | .["cve-id"]] | unique}) | 
  map(select(.cves | length > 1)) |
  (["| Component | CVEs |",
    "| --------- | ---- |"] +
   [.[] | "| \(.name) | \(.cves | join(", ")) |"]) | 
  .[]' cve.json
| Component | CVEs |
| --------- | ---- |
| Microsoft.NETCore.App.Runtime | CVE-2024-30105, CVE-2024-38081, CVE-2024-38095 |
```

#### Get all patches needed for a release

```bash
$ jq -r '[.core[], .extensions[]] | 
  map(select(.release == "8.0")) | 
  group_by(.name) | 
  map({name: .[0].name, versions: [.[] | .fixed] | unique | sort}) | 
  (["| Version | Component |", "| ------- | --------- |"] + 
  map("| \(.versions | last)   | \(.name) |")) | 
  .[]' cve.json
| Version | Component |
| ------- | --------- |
| 8.0.7   | Microsoft.AspNetCore.App.Runtime |
| 8.0.7   | Microsoft.NETCore.App.Runtime |
| 8.0.1   | System.Formats.Asn1 |
| 8.0.4   | System.Text.Json |
```

#### Show release-independent extensions

Useful for tracking updates to extensions not tied to .NET releases:
```bash
$ jq -r '.extensions[] | 
  select(.release == null) |
  [{cve: .["cve-id"], version: .fixed, name: .name}] |
  (["| CVE ID        | Version | Extension |",
    "| ------------- | ------- | --------- |"] +
   [.[] | "| \(.cve)  | \(.version)    | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Version | Extension |
| ------------- | ------- | --------- |
| CVE-2024-38081  | 6.0.1    | Microsoft.IO.Redist |
```

#### Repository-level commit summary

```bash
$ jq -r '. as $root | 
  .commits | 
  to_entries | 
  group_by(.value.repo) | 
  map({
    repo: .[0].value.repo, 
    commits: [.[] | .key] | length, 
    cves: ([.[] | .key as $hash | $root["cve-commits"] | to_entries[] | select(.value[] == $hash) | .key] | unique | length)
  }) | 
  (["| Repository | Commits | CVEs |",
    "| ---------- | ------- | ---- |"] +
   [.[] | "| \(.repo)  | \(.commits)       | \(.cves)    |"]) | 
  .[]' cve.json
| Repository | Commits | CVEs |
| ---------- | ------- | ---- |
| aspnetcore  | 1       | 1    |
| runtime  | 4       | 3    |
```

#### Check if specific version is vulnerable

```bash
$ jq -r --arg release "8.0" --arg version "8.0.5" '
  [.core[], .extensions[]] | 
  map(select(.release == $release)) |
  map(select(.["min-vulnerable"] <= $version and .["max-vulnerable"] >= $version)) |
  (["| CVE ID        | Component |",
    "| ------------- | --------- |"] +
   [.[] | "| \(.["cve-id"])  | \(.name) |"]) | 
  .[]' cve.json
| CVE ID        | Component |
| ------------- | --------- |
| CVE-2024-30105  | Microsoft.NETCore.App.Runtime |
| CVE-2024-35264  | Microsoft.AspNetCore.App.Runtime |
| CVE-2024-38095  | Microsoft.NETCore.App.Runtime |
| CVE-2024-30105  | System.Text.Json |
```

## Appendix: Schema Design and Query Tradeoff Analysis

This schema was designed with "queryability as a primary design concern" - optimizing for common security operations workflows over theoretical data modeling purity. This appendix analyzes the key design decisions and their impact on query complexity.

### Design Philosophy: Optimizing for Query Simplicity

The schema employs **strategic denormalization** - intentionally duplicating data to make queries simpler. For example, `System.Formats.Asn1` appears twice in the extensions array - once for each CVE/release combination it's affected by.

This denormalization trades storage efficiency for query simplicity:
- **Normalized approach**: One object per component, nested ranges for different CVEs
- **Denormalized approach**: Separate objects for each CVE/component combination

Since CVE data is queried far more often than it's updated, this trade-off optimizes for the common case of reading and analyzing the data.

### Current Schema vs Alternative Approaches

We evaluated three main approaches:

#### 1. Current Schema (Flat Denormalized)
```json
{
  "extensions": [
    {"cve-id": "CVE-2024-38095", "name": "System.Formats.Asn1", "release": "6.0", "fixed": "6.0.1"},
    {"cve-id": "CVE-2024-38095", "name": "System.Formats.Asn1", "release": "8.0", "fixed": "8.0.1"}
  ]
}
```

#### 2. Hybrid Schema (Package-Centric with Ranges)
```json
{
  "extensions": [
    {
      "name": "System.Formats.Asn1",
      "ranges": [
        {"cve-id": "CVE-2024-38095", "release": "6.0", "fixed": "6.0.1"},
        {"cve-id": "CVE-2024-38095", "release": "8.0", "fixed": "8.0.1"}
      ]
    }
  ]
}
```

#### 3. Ranges Schema (OSV-Style)
```json
{
  "affected": [
    {
      "package": {"name": "System.Formats.Asn1"},
      "ranges": [
        {"type": "ECOSYSTEM", "events": [{"introduced": "6.0.0", "fixed": "6.0.1"}]}
      ]
    }
  ]
}
```

### Query Complexity Analysis

The following table compares query complexity across schemas for common operations:

| Query Pattern | Current Schema | Hybrid Schema | Ranges Schema | Primary Use Case |
|---------------|----------------|---------------|---------------|------------------|
| **CVE → Components** | ✅ Simple filter | ❌ Nested select | ❌ Double nested | **High priority** |
| **Component → CVEs** | ✅ Direct field | ❌ Array traversal | ✅ Direct field | **High priority** |
| **Version vulnerability check** | ✅ Top-level fields | ❌ Nested access | ❌ Event parsing | **High priority** |
| **Release-specific patches** | ✅ Simple filter | ❌ Nested filter | ❌ Complex logic | **Medium priority** |
| **Components with multiple CVEs** | ❌ Group-by needed | ✅ Direct check | ✅ Direct field | **Low priority** |
| **Package deduplication** | ❌ Duplicates exist | ✅ No duplicates | ✅ No duplicates | **Low priority** |

**Result**: Current schema wins 4/6 query patterns, optimizing for the highest-priority security operations.

### Detailed Query Examples

#### "Which components are affected by CVE-2024-38095?"

**Current Schema (Winner):**
```bash
jq -r '[.core[], .extensions[]] | 
  map(select(.["cve-id"] == "CVE-2024-38095")) | 
  .[].name'
```

**Hybrid Schema:**
```bash
jq -r '[.core[], .extensions[]] | 
  map(select(.ranges[]? | .["cve-id"] == "CVE-2024-38095")) | 
  .[].name'
```

**Ranges Schema:**
```bash
jq -r '.affected[] | 
  select(.ranges[] | .events[] | has("cve_id") and .cve_id == "CVE-2024-38095") | 
  .package.name'
```

The current schema requires the simplest filter logic for this critical security operation.

#### "Which components have multiple vulnerabilities?"

**Current Schema:**
```bash
jq -r '[.core[], .extensions[]] | 
  group_by(.name) | 
  map(select(length > 1)) | 
  .[] | "\(.[0].name): \([.[] | .["cve-id"]] | unique | length) CVEs"'
```

**Hybrid Schema (Winner):**
```bash
jq -r '[.core[], .extensions[]] | 
  map(select(.ranges | map(.["cve-id"]) | unique | length > 1)) |
  .[] | "\(.name): \(.ranges | map(.["cve-id"]) | unique | length) CVEs"'
```

The hybrid approach eliminates the need for grouping operations in this less common query.

### Join Indices: Additional Denormalization

The schema includes pre-computed join indices that further optimize queries:

```json
{
  "cve-releases": {
    "CVE-2024-38095": ["6.0", "8.0"]
  },
  "release-cves": {
    "8.0": ["CVE-2024-30105", "CVE-2024-35264", "CVE-2024-38095"]  
  },
  "cve-commits": {
    "CVE-2024-38095": ["979135d5...", "4a8d5a0..."]
  }
}
```

These indices break normalization principles by introducing redundancy, but transform complex multi-stage joins into simple lookups:

**Without Indices:**
```bash
# Find releases affected by a CVE - requires scanning all components
jq -r '[.core[], .extensions[]] | 
  map(select(.["cve-id"] == "CVE-2024-38095")) | 
  map(.release) | unique'
```

**With Indices:**
```bash
# Direct lookup - no scanning required
jq -r '.["cve-releases"]["CVE-2024-38095"][]'
```

### Comparison to Industry Standards

#### OSV Schema
The [OSV Schema](https://ossf.github.io/osv-schema/) prioritizes package-centric operations:
- **Strength**: Natural for dependency scanning tools
- **Weakness**: Complex for CVE-centric security analysis  
- **Best for**: Software composition analysis workflows

#### CVE.org JSON Format  
If the [CVE Assignment Information Format](https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html) were JSON:
- **Strength**: CVE-centric structure matches security workflows
- **Weakness**: No structured component/version relationships
- **Best for**: Vulnerability disclosure and tracking

#### Our Schema
Bridges both approaches:
- **CVE metadata**: Separate for disclosure workflows  
- **Component impact**: Denormalized for analysis workflows
- **Join indices**: Pre-computed for common cross-cutting queries
- **Best for**: Security operations and patch management

### Storage vs Query Performance Trade-offs

| Aspect | Current Schema | Alternative Approaches |
|--------|----------------|----------------------|
| **File size** | ~15% larger due to duplication | Smaller, more normalized |
| **Query complexity** | Simple for 80% of use cases | Complex for common operations |
| **Parse performance** | Fast (flat structure) | Slower (nested traversal) |
| **Maintainability** | Indices require updates | Single source of truth |
| **LLM consumption** | Optimized (simple patterns) | Harder to process |

### Design Validation Through Testing

We validated this design by implementing actual `jq` queries for all documented use cases. The principle was: **"If the `jq` queries look bad, the schema is bad."**

Key findings:
- Simple queries = better human comprehension
- Simple queries = better LLM processing  
- Flat structures = faster parsing
- Pre-computed indices = predictable performance

### Conclusion

The current schema prioritizes **queryability over normalization** because:

1. **Access patterns** are heavily read-biased and CVE-centric
2. **Query simplicity** directly impacts adoption and tooling
3. **Storage cost** of duplication is negligible compared to query complexity cost
4. **Performance predictability** matters more than theoretical efficiency

This represents a **pragmatic over pure** approach - choosing usability over textbook normalization principles.

The small storage overhead buys significant simplification in the queries that security teams run daily, making this a worthwhile trade-off for a security-focused analytical schema.

## Appendix -- CVE Assignment Information Format

From: <https://cve.mitre.org/cve/list_rules_and_guidance/cve_assignment_information_format.html>

```text
Where applicable, make use of industry standards when describing vulnerabilities.

[PRODUCT]

As a general guideline, [PRODUCT] should include the vendor, developer, or project name as well as the name of the actual software or hardware in which the vulnerability exists.

[VERSION]

[VERSION] should include the version, date of release, or whatever indicator that is used by vendors, developers, or projects to differentiate between releases. [VERSION] can be described with specific version numbers, ranges of versions, or “all versions before/after” a version number or date.

[PROBLEMTYPE]

As mentioned above, [PROBLEMTYPE] can include an arbitrary summary of the problem, though Common Weakness Enumerations (CWEs) are an excellent standard to use in this field.

[REFERENCES]

[REFERENCES] should be URLs pointing to a world-wide-web-based resource. For CSV and flat-file formats, they should be separated by a space. References should point to content that is relevant to the vulnerability and include at least all the details included in the CVE entry. Ideally, references should point to content that includes the CVE ID itself whenever possible. References must also be publicly available, as described in Section 2.1.1 of the CVE Numbering Authorities (CNA) Rules.

[DESCRIPTION]

The [DESCRIPTION] field is a plain language field that should describe the vulnerability with sufficient detail as to demonstrate that the vulnerability is unique. The required information listed above should be included in the [DESCRIPTION], as well as other details the author feels are relevant or necessary to show uniqueness.

Specifically, the [DESCRIPTION] field could also include:

An explanation of an attack type using the vulnerability;
The impact of the vulnerability;
The software components within a software product that are affected by the vulnerability; and
Any attack vectors that can make use of the vulnerability.
Descriptions often follow this template:

     [PROBLEM TYPE] in [PRODUCT/VERSION] causes [IMPACT] when [ATTACK]

where impact and attack are arbitrary terms that should be relevant to the nature of the vulnerability.

[ASSIGNINGCNA]

The [ASSIGNINGCNA] field should include the name of the assigning CNA. CNAs should use a consistent name to facilitate searches for CVE IDs that originate from them.

Correctly Formatted Example
Following is an example of the reporting format in use. In this case, the Sub-CNA “BigCompanySoft” is assigning a CVE ID to versions of their product.

[CVEID]: CVE-2016-123455
[PRODUCT]: BIGCOMPANYSOFT SOFTWARE PRODUCT
[VERSION]: All versions prior to version 2.5
[PROBLEMTYPE]: Arbitrary Code Execution
[REFERENCES]: http://bigcompanysoft.com/vuln/v1232.html
[DESCRIPTION]: CoreGraphics in BIGCOMPANYSOFT SOFTWARE PRODUCT before 2.5 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted BMP image.
[ASSIGNINGCNA]: BigCompanySoft
```
